\documentclass[12pt,a4paper]{report}

\usepackage[utf8]{inputenc} % pentru suport diacritice
\usepackage[romanian]{babel} % setări pentru limba română 
%\renewcommand\familydefault{\sfdefault} % sans serif

\usepackage[margin=2.54cm]{geometry}	% dimensiuni pagină și margini
\usepackage{graphicx} % support the \includegraphics command and options
\usepackage{subcaption} % subfiguri

% formatting sections and subsections
\usepackage{textcase}
\usepackage[titletoc, title]{appendix}
\usepackage{titlesec}
\titleformat{\chapter}{\large\bfseries}{\thechapter}{2ex}{\MakeUppercase}[\vspace*{-1.5cm}]
\titleformat*{\section}{\large\bfseries}
\titleformat*{\subsection}{\large\bfseries}
\titleformat*{\subsubsection}{\large\bfseries}

\usepackage{chngcntr}
%\counterwithout{figure}{chapter} % no chapter number in figure labels
%\counterwithout{table}{chapter} % no chapter number in table labels
%\counterwithout{equation}{chapter} % no chapter number in equation labels

\usepackage{booktabs} % for much better looking tables
\usepackage{url} % Useful for inserting web links nicely
\usepackage[bookmarks,unicode,hidelinks]{hyperref}

\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
%\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
\usepackage{float}
\usepackage{enumitem}
\setlist{noitemsep}


\def\figureautorefname{figura}

\usepackage{tikz} % figure drawing
\usepackage{listings} % code snippets

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}


\renewcommand{\lstlistingname}{Extras de cod}
\def\lstlistingautorefname{extrasul de cod}
\lstdefinestyle{myC++}{ %
	language=C++,
	backgroundcolor=\color{white},   % choose the background color
	basicstyle=\linespread{0.7}\footnotesize,        % size of fonts used for the code
	breaklines=true,                 % automatic line breaking only at whitespace
	captionpos=b,                    % sets the caption-position to bottom
	commentstyle=\color{mygreen},    % comment style
	escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
	keywordstyle=\color{blue},       % keyword style
	stringstyle=\color{mymauve},     % string literal style
	tabsize=4,
	morekeywords={Obj,obj,vec3,quat},
}

\usepackage{xcolor}

\colorlet{punct}{red!60!black}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}

\lstdefinelanguage{json}{
	basicstyle=\linespread{0.7}\footnotesize,
	numbers=left,
	numberstyle=\scriptsize,
	stepnumber=1,
	captionpos=b,
	numbersep=8pt,
	showstringspaces=false,
	breaklines=true,
	frame=lines,
	backgroundcolor=\color{white},
	literate=
	*{0}{{{\color{numb}0}}}{1}
	{1}{{{\color{numb}1}}}{1}
	{2}{{{\color{numb}2}}}{1}
	{3}{{{\color{numb}3}}}{1}
	{4}{{{\color{numb}4}}}{1}
	{5}{{{\color{numb}5}}}{1}
	{6}{{{\color{numb}6}}}{1}
	{7}{{{\color{numb}7}}}{1}
	{8}{{{\color{numb}8}}}{1}
	{9}{{{\color{numb}9}}}{1}
	{:}{{{\color{punct}{:}}}}{1}
	{,}{{{\color{punct}{,}}}}{1}
	{\{}{{{\color{delim}{\{}}}}{1}
	{\}}{{{\color{delim}{\}}}}}{1}
	{[}{{{\color{delim}{[}}}}{1}
	{]}{{{\color{delim}{]}}}}{1},
}

\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{algorithmicx}

\makeatletter
\renewcommand{\ALG@name}{Algoritmul}

\renewcommand\algorithmicend{\textbf{sfârșit}}
\renewcommand\algorithmicloop{\textbf{repetă}}
\renewcommand\algorithmicif{\textbf{dacă}}
\renewcommand\algorithmicthen{\textbf{atunci}}
\renewcommand\algorithmicreturn{\textbf{întoarce}}
\renewcommand\algorithmicfunction{\textbf{funcție}}
\makeatother

\usepackage{amsmath}
\DeclareMathOperator*{\argmax}{\arg\!\max}
\DeclareMathOperator*{\argmin}{\arg\!\min}
\usepackage{amssymb}
\usepackage{amsthm}

\newtheorem{theorem}{Teorema}[]

\usepackage{chngcntr}
\counterwithin{figure}{chapter}

%%% HEADERS & FOOTERS
\usepackage{fancyhdr}
\pagestyle{empty}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}



\newcommand{\HeaderLineSpace}{-0.5cm}
\newcommand{\UniTextRO}{UNIVERSITATEA POLITEHNICA DIN BUCUREȘTI \\[\HeaderLineSpace] 
FACULTATEA DE AUTOMATICĂ ȘI CALCULATOARE \\[\HeaderLineSpace]
DEPARTAMENTUL CALCULATOARE\\}
\newcommand{\DiplomaRO}{PROIECT DE DIPLOMĂ}
\newcommand{\AdvisorRO}{Coordonator științific:}
\newcommand{\BucRO}{BUCUREȘTI}

\newcommand{\UniTextEN}{UNIVERSITY POLITEHNICA OF BUCHAREST \\[\HeaderLineSpace]
FACULTY OF AUTOMATIC CONTROL AND COMPUTERS \\[\HeaderLineSpace]
COMPUTER SCIENCE DEPARTMENT\\}
\newcommand{\DiplomaEN}{DIPLOMA PROJECT}
\newcommand{\AdvisorEN}{Thesis advisor:}
\newcommand{\BucEN}{BUCHAREST}

\newcommand{\frontPage}[6]{
\begin{titlepage}
\begin{center}
{\Large #1}  % header (university, faculty, department)
\vspace{50pt}
\begin{tabular}{p{6cm}p{4cm}}
\includegraphics[scale=0.8]{pics/upb-logo.jpg} &
	\includegraphics[scale=0.5,trim={14cm 11cm 2cm 5cm},clip=true]{pics/cs-logo.pdf}
\end{tabular}

\vspace{105pt}
{\Huge #2}\\                           % diploma project text
\vspace{40pt}
{\Large #3}\\ \vspace{0pt}  % project title
{\Large #4}\\                          % project subtitle
\vspace{40pt}
{\LARGE \Name}\\                   % student name
\end{center}
\vspace{60pt}
\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}p{6cm}r}
&{\large\textbf{#5}}\vspace{10pt}\\      % scientific advisor
&{\large \Advisor}                                    % advisor name
\end{tabular*}
\vspace{20pt}
\begin{center}
{\large\textbf{#6}}\\                                % bucharest
\vspace{0pt}
{\normalsize \Year}
\end{center}
\end{titlepage}
}

\newcommand{\frontPageRO}{\frontPage{\UniTextRO}{\DiplomaRO}{\ProjectTitleRO}{\ProjectSubtitleRO}{\AdvisorRO}{\BucRO}}
\newcommand{\frontPageEN}{\frontPage{\UniTextEN}{\DiplomaEN}{\ProjectTitleEN}{\ProjectSubtitleEN}{\AdvisorEN}{\BucEN}}

\linespread{1.5}
\setlength\parindent{0pt}
\setlength\parskip{.28cm}

%% Abstract macro
\newcommand{\AbstractPage}{
\begin{titlepage}
\textbf{\large SINOPSIS}\par
\AbstractRO\par\vfill
\textbf{\large ABSTRACT}\par
\AbstractEN \vfill
\end{titlepage}
}

%% Thank you macro
\newcommand{\ThanksPage}{
\begin{titlepage}
{\noindent \large\textbf{MULȚUMIRI}}\\
\Thanks
\end{titlepage}
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   
%%
%%          End of template definitions
%%   
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%% Puteți elimina aceste linii din lucrare, servesc numai pentru template.
\newcommand{\worktype}[1]{[\textit{#1}] }
\newcommand{\dezvoltare}{\worktype{Dezvoltare de produs}}
\newcommand{\cercetare}{\worktype{Cercetare}}
\newcommand{\ambele}{\worktype{Ambele}}
%%%


%%
%%   Campurile de mai jos trebuie modificate de autor. Modificati doar continutul, nu si numele fiecarei definitii
%%
\newcommand{\ProjectTitleRO}{Simularea interacțiunilor fizice}
\newcommand{\ProjectSubtitleRO}{~}
\newcommand{\ProjectTitleEN}{Simulation of physical interactions}
\newcommand{\ProjectSubtitleEN}{~}
\newcommand{\Name}{Cristian-Andrei SANDU}
\newcommand{\Advisor}{Prof. dr. ing. Costin-Anton BOIANGIU}
\newcommand{\Year}{2018}

% Setări document
\title{Proiect de diplomă}
\author{\Name}
\date{\Year}

%%
%%   Campurile aferente rezumatului
%%
\newcommand{\AbstractRO}{Lucrarea de față are obiectivul de a prezenta o serie de fenomene fizice ce țin de cinematica corpurilor solide, diferiți algoritmi și metode numerice utilizate pentru a simula aceste fenomene și punerea lor în aplicare sub forma unui simulator de interacțiuni mecanice, capabil să aproximeze și să afișeze în timp real mișcarea realistică a unui număr de obiecte pe ecran. Rezultatul este o aplicație \textit{OpenGL} capabilă să ruleze o serie de demo-uri și care oferă utilizatorului posibilitatea de a interacționa cu acestea (să vizualizeze scena, să poată introduce obiecte noi și să poată modifica parametri).}
%Sinopsisul proiectului are rol de introducere, conținând atât o descriere pe scurt a problemei abordate cât și o enumerare sumară a rezultatelor și a concluziilor. Se recomandă ca sinopsisul să fie redactat într-un limbaj accesibil unei persoane nefamiliarizate cu domeniul, dar în același timp destul de specific pentru a oferi rapid o vedere de ansamblu asupra proiectului prezentat.
%Sinopsisul proiectului va fi redactat atât în română cât și în engleză. Ca dimensiunea recomandată aceasta secțiune va avea maxim 200 de cuvinte pentru fiecare variantă. Împreună, ambele variante se vor încadra într-o singură pagină.}

\newcommand{\AbstractEN}{The aim of this thesis is to provide a closer look at a series of physical phenomena pertaining to the motion of solid objects, as well as to describe various algorithms and numerical methods used in motion simulation and implementing them inside a physics engine able to approximate and render the realistic motion of a number of objects in real time. The achieved result is an \textit{OpenGL} application able to run a series of demos and also provide the user with means for interacting with them (view the scene, insert new objects or change simulation parameters).}
%The abstract has an introductory role and should engulf both a brief description of the issue at hand, as well as an overview of the obtained results and conclusions. The abstract should be formulated such that even somebody that is unfamiliar with the projects’ domain can grasp the objectives of the thesis while, at the same time, retaining a specificity level offering a bird’s eye view of the project.
%The projects’ abstract will be elaborated in both Romanian and English. The recommended size for this section is limited to 200 words for each version. Together, both versions will fit in one page.}

%%
%%   Campurile aferente paginii de multumiri
%%
\newcommand{\Thanks}{TODO:(opțional) Aici puteți introduce o secțiunea specială de mulțumiri / acknowledgments. }

\begin{document}

\frontPageRO
\frontPageEN

\begingroup
\linespread{1}
\tableofcontents
\endgroup

\AbstractPage

% poate fi comentata sau stearsa
%\ThanksPage


% Textul licentei incepe de aici 


\chapter{Introducere}\pagestyle{fancy}
% * <marios.choudary@gmail.com> 2018-02-28T11:38:18.106Z:
% 
% > INTRODUCERE
% Am scos de aici referintele la font pentru a nu mai fi dependenti de Calibri. Personal, nici nu sunt sigur ca ajuta prea mult aceasta recomandare si mi se pare bun font-ul default din Latex (Computer Modern). Daca sunteti de-acord, va rog sa stergeti liniile comentate de mai jos, precum si cele referitoare la fontul Calibri din restul documentului.
% 
% ^.
%Parametrii de formatare recomandați pentru lucrare: 
%\begin{itemize}
% %\item Font recomandat: Calibri; Dimensiune font: 12; 
% \item Dimensiune font: 12; 
% \item Spațiere între linii: 1,5; Spațiere după paragraf: 8pt;
% \item Stil: Justified;
% \item Dimensiune pagină: A4; Margini: 2,54cm/ 2,54cm/ 2,54cm/ 2,54cm;
% %\item Heading1: Calibri, 14, bold, all caps;
% %\item Heading2: Calibri, 14, bold;
% %\item Heading3: Calibri, 12. 
% %\item Font pentru formule: Cambria Math, 12.
% \item Heading1: 14, bold, all caps;
% \item Heading2: 14, bold;
% \item Heading3: 12. 
% \item Font size pentru formule: 12.
%\end{itemize}
%În cadrul introducerii, este necesară abordarea următoarelor puncte care reprezintă de fapt familiarizarea cititorului (comisia, alți colegi sau experți în domeniu) cu tema proiectului, soluția propusa și cuprinsul/structura lucrării. Deși introducerea poate conține și unele elemente mai generale, se recomandă păstrarea unui limbaj tehnic, specific audienței care va citi lucrarea.
%
%În cadrul capitolelor următoare, veți regăsi o serie notații de forma \dezvoltare, \cercetare. Acest tip de formatare este utilizat exclusiv în acest template pentru a marca sfaturi și cerințe specifice pentru lucrări de diploma cu specific diferit. În pregătirea documentului vostru, nu veți utiliza aceste marcaje. 
%Elementele pe care trebuie să le abordați în introducere sunt descrise în cadrul subcapitolelor de mai jos. 
Simularea interacțiunilor fizice pe un computer se realizează pe baza unui \textbf{motor de fizică} (eng. \textit{physics engine}) care are rolul de a prelua starea scenei la un moment discret de timp $t_i$ și de a determina starea la momentul $t_{i+1}$. Întrucât acest lucru se realizează într-un spațiu discret, se dorește de fapt obținerea unei aproximări cât mai bune a fenomenelor fizice din realitate. Pentru că fizica este un domeniu extrem de vast, lucrarea de față are ca subiect doar simularea interacțiunilor mecanice dintre corpuri, lăsând aprofundarea altor tipuri de forțe și fenomene la latitudinea cititorilor interesați de domeniu. 
\section{Context}
%O scurtă introducere a proiectului, motivație, explicație de ce este relevant domeniul proiectului.
Proiectul a luat naștere ca urmare a interesului autorului pentru mecanică și grafică pe calculator și dorința de a aprofunda pașii necesari implementării unui sistem informatic robust, realistic, ușor de folosit și plăcut vederii.
Aplicabilitatea unui astfel de simulator se reflectă într-o multitudine de domenii: jocuri video, proiectare și testare de sisteme mecanice (complexitatea variind de la angrenaje simple până la mașini, avioane), balistică (de natură militară sau civilă), didactică (prin oferirea unei perspective ușor de urmărit și de înțeles în studiul mecanicii).
\section{Problema} 
%Care este problema pe care proiectul o va rezolva.
Se dorește obținerea unei aplicații care să ofere utilizatorului capabilitatea de a rula simulări pentru niște scenarii definite programatic și editabile în timpul execuției printr-o interfață grafică.
Se disting, prin urmare, două subprobleme de rezolvat:
\begin{enumerate}
	\item \textbf{motorul de fizică} care să simuleze mișcarea și interacțiunile corpurilor din scenă
	\item \textbf{interfața cu utilizatorul}
\end{enumerate}
\section{Obiective}
%Care sunt obiectivele proiectului/soluției/abordării/ideii; Ce creșteri sau evoluții determină rezolvarea proiectului.
În continuarea celor menționate anterior, sunt delimitate următoarele obiective atinse în elaborarea lucrării de față și a aplicației asociate:
\begin{itemize}
	\item alegerea unei reprezentări robuste pentru starea (din punct de vedere cinematic) unui obiect al scenei
	\item integrarea mărimilor secundare (de ex. accelerația, viteza) în vederea obținerii stării noi a obiectului
	\item detecția potențialelor coliziuni între obiecte
	\item generarea punctelor de contact între obiectele aflate în coliziune
	\item rezolvarea contactelor generate cu un răspuns realistic
	\item desenarea obiectelor pe ecran
	\item implementarea unui algoritm de ray-casting pentru selectarea unui obiect de pe ecran cu ajutorul mouse-ului
	\item implementarea unei interfețe grafice pentru controlul simulării și modificarea de elemente ale scenei
\end{itemize}
\section{Soluția propusă} 
%Descrierea pe scurt a soluției implementate; ce abordare este propusă (nu detalierea utilitarelor și a tehnologiilor, ci abordarea și ideea propusă de către autor).
În vederea atingerii tuturor obiectivelor de mai sus, este propusă o aplicație \textit{OpenGL}, capabilă să preia input-ul utilizatorului și să deseneze un număr de scenarii demonstrative.
Backend-ul (motorul de fizică în sine) va urmări o arhitectură clasică, folosită cu succes în alte proiecte asemănătoare (ex: \textit{box2D}\cite{box2D}, \textit{bullet}\cite{bullet}). Funcționarea simulatorului este asigurată de o buclă infinită în care la fiecare iterație sunt realizate, pe rând: tratarea input-ului utilizatorului, integrarea (actualizarea stării) corpurilor solide,
detecția coliziunilor, rezolvarea lor, desenarea în contextul \textit{OpenGL}.
\section{Rezultatele obținute}
În urma realizării acestei lucrări, am dobândit cunoștințe semnificative în domeniul simulării interacțiunilor mecanice și al implementării de motoare de fizică robuste și eficiente.

În plus, am obținut o aplicație grafică \textit{OpenGL}, capabilă să ruleze o simulare de dimensiune rezonabilă (max. 64 de obiecte într-o scenă) a interacțiunilor mecanice dintre corpuri 3D, cuplată cu o interfață grafică pentru utilizator, prin care acesta poate încărca sau salva scene și controla parametrii simulării sau direct obiectele din scenă.
 
\section{Structura lucrării}
%Un paragraf în care fiecare dintre secțiunile următoare este prezentată în 1-2 fraze, punând accentul pe elementele cele mai semnificative din fiecare secțiune.
În continuare voi prezenta pe scurt fiecare secțiune a acestei lucrări, care urmărește, în mare, șablonul oficial.
\begin{enumerate}
	\setcounter{enumi}{1}
	\item \textbf{Motivație și analiza cerințelor}: sunt detaliate atât motivația realizării proiectului propus, cât și funcționalitățile oferite de aplicație, în raport cu cerințele care trebuie acoperite.
	\item \textbf{Metode existente}: sunt analizate metodele disponibile pentru atingerea fiecăruia dintre obiectivele propuse, modul în care acestea sunt folosite în soluții similare și o evaluare a acestor metode. Fiecare subproces al simulatorului va avea propria subsecțiune.
	\item \textbf{Soluția propusă}: sunt motivate alegerile și deciziile luate la nivel structural, iar soluția va fi descrisă pe larg, din punct de vedere teoretic.
	\item \textbf{Detalii de implementare}: este prezentată arhitectura aplicației și orice detalii de implementare considerate a fi relevante (algoritmi folosiți, etapele dezvoltării - cu dificultăți întâmpinate și soluții descoperite)
	\item \textbf{Evaluare}: analiză a performanțelor aplicației și a gradului de atingere a obiectivelor propuse
	\item \textbf{Concluzii}: este sumarizat întregul proiect, trecând din nou peste elementele constituente (obiective, implementare, rezultate obținute); în plus, sunt oferite perspective pentru dezvoltarea ulterioară a proiectului.
\end{enumerate}



\chapter{Motivație}
Motivul pentru care am ales să realizez proiectul de față este unul personal, acela de a aprofunda tehnicile matematice și programatice folosite într-o simulare realistică a interacțiunilor mecanice dintre corpuri 3D. Pe parcursul realizării acestuia, am avut în vedere și posibilitatea îmbunătățirii uneia sau mai multora dintre aceste tehnici.

Faptul că în sfera dezvoltării de aplicații grafice sau jocuri accentul se pune mai ales pe partea practică -- e de preferat să se obțină o aplicație care rulează mai bine și care este plăcută ochiului decât una foarte riguroasă din punct de vedere teoretic -- a dat naștere multor soluții mai mult sau mai puțin "hacky", dar foarte interesante. Am ales astfel să nu urmăresc obținerea de rezultate teoretice remarcabile, și să mă concentrez pe înțelegerea și implementarea unor astfel de metode.

Proiectul poate fi considerat, în fapt, o "testare a apelor" în domeniul simulării de fizică în timp real, un exercițiu pentru abilitățile mele de programare eficientă, robustă, orientată pe obiecte, dar și o îmbunătățire a cunoștințelor mele de C++.

Consider că ce am dobândit în urma realizării acestui proiect mă va ajuta să înțeleg mai bine subtilitățile din spatele unui motor de fizică state-of-the-art, astfel încât, pe viitor, să fiu capabil de a contribui la proiecte open-source deja existente (ex. \textit{bullet}\cite{bullet}) sau, de ce nu, să efectuez muncă în cercetare sau în industrie în acest domeniu, la un nivel ceva mai complex și actual.



%\dezvoltare Acest capitol va analiza cerințele produsului din prisma potențialilor clienți și a scenariilor de utilizare preconizate, urmând a fi generată o lista de funcționalități. 
%
%\cercetare Acest capitol va introduce motivația realizării proiectului propus.
%
%Dacă proiectul de licență face parte dintr-un proiect mai amplu (de exemplu un proiect complex, la care lucrează 2 studenți (ex: 1 student la front-end-ul aplicației, 1 student la back-end-ul aplicației), în acest capitol va fi explicat pe scurt ansamblul proiectului și ce parte din proiect este adresată de lucrarea propusă. 
%
%Criterii pentru calificativul \textit{Ne\textit{Satisfăcător}}: 
%\begin{itemize}
%	\item \dezvoltare Cerințele sunt imaginate de student pe baza unei analize a pieței;
%	\item \cercetare Nu se oferă o motivație valida.
%\end{itemize}
%
%Criterii pentru calificativul \textit{Satisfăcător}: 
%\begin{itemize}
%	\item \dezvoltare Există un interviu, un client, analiza cerințelor este elaborată pe baza interviului;
%	\item \cercetare Motivația este doar personala.
%\end{itemize}
%
%
%Criterii pentru calificativul \textit{Bine}: 
%\begin{itemize}
%	\item	 \dezvoltare Proces iterativ pe baza unor interviuri cu mai mulți clienți, dezvoltare MVP, reevaluare cerințe;
%	\item	 \cercetare Motivația este legata de o necesitate științifica / tehnica explicită.
%\end{itemize}


\chapter{Metode Existente}
Pentru început, ar trebui menționat că un motor de fizică este foarte rar întâlnit de sine stătător, el constituind de cele mai multe ori o parte esențială a unei aplicații mult mai complexe (care cuprinde și alte motoare/instrumente necesare funcționării). De aceea, voi ignora sisteme precum motoarele pentru dezvoltarea jocurilor (\textit{Unreal Engine}\cite{unreal}, \textit{Source}\cite{source}, \textit{Unity}\cite{unity} etc.) sau simulatoare științifice și mă voi concentra strict pe expunerea particularităților motoarelor de fizică de sine stătătoare.
\section{Aplicații similare}
Deoarece cele mai multe aplicații nu au nevoie de toate particularitățile unui motor de fizică complex și foarte general, o practică des întâlnită este ca companiile să își implementeze unul propriu, optimizat pentru cerințele specifice ale aplicațiilor dezvoltate. Chiar și așa, putem aminti câteva dintre cele mai populare middleware-uri: 
\begin{itemize}
	\item \textbf{Box2D}\cite{box2D} este un motor de fizică open source, capabil să simuleze corpuri solide în 2D. Oferă suport pentru detecție continuă a coliziunilor, poligoane convexe și cercuri, corpuri compuse, soluționarea contactelor cu frecare, articulațiilor etc și folosește un \hyperref[BVH]{arbore dinamic} pentru faza preliminară a detecției coliziunilor. Scris în C++, a fost ulterior portat și în alte limbaje și este apreciat pentru simplitatea lui și folosit de dezvoltatori independenți, și a fost inclus chiar și în \textit{Unity}\cite{unity} ca opțiune pentru motorul de fizică 2D.
	\item \textbf{Bullet}\cite{bullet} este probabil cel mai cunoscut motor de fizică open source în lumea 3D. Oferă suport pentru detecția discretă sau continuă a coliziunilor pentru toate primitivele de bază, dar și pentru mesh-uri convexe, simularea corpurilor deformabile, articulații și constrângeri complexe, mișcarea vehiculelor etc. Este folosit în jocuri, robotică, efecte speciale în filme și este inclus în software precum \textit{Godot}\cite{godot}, \textit{Blender Game Engine}\cite{blender} sau \textit{Unity 3D}\cite{unity}.
	\item Din sfera closed source, poate fi amintit \textbf{NVIDIA PhysX}\cite{physx}, unul dintre cele mai populare motoare de fizică în industria jocurilor video - inclus în \textit{Unreal Engine 3+}\cite{unreal}, \textit{Unity 3D}\cite{unity} și folosit de companii ca \textit{EA}, \textit{THQ}, \textit{2K Games}. \textit{Physx} folosește accelerare hardware pe GPU, plăcile video \textit{GeForce} de la \textit{NVIDIA} fiind capabile să ofere o creștere exponențială a puterii de procesare a simulărilor fizice.  
\end{itemize}
\section{Soluții curente}
Secțiunea următoare va pune în evidență starea actuală a dezvoltării de motoare de fizică, oferind o perspectivă asupra unor algoritmi și metode numerice care sunt folosite în prezent. Gruparea acestora urmărește componentele standard ale unui simulator de interacțiuni fizice.
\subsection{Câteva noțiuni matematice referite și utilizate de algoritmii de mai jos}
\begin{itemize}
	\item O \textbf{funcție suport} a unei mulțimi pe o direcție este definită ca:
	$$ h_A:\mathbb{R}^{n} \mapsto \mathbb{R} \textrm{, cu }A \subset \mathbb{R}^{n}\textrm{,  } h_A(d) = \sup \left\lbrace d\cdot a\ |\ a\in A\right\rbrace $$
	Este utilizată în determinarea \textbf{punctelor suport} (cel mai îndepărtat punct al unui obiect într-o anumită direcție). Formele elementare (cub, sferă, con etc.) au funcții suport foarte ușor de calculat, mai ales în spațiul local al corpului.
	\label{support_points}
	\item \textbf{Suma Minkowski} a două mulțimi de puncte $A$ și $B$ este mulțimea
	$$ A \oplus B = \left\lbrace a + b\ |\ a \in A, b \in B \right\rbrace $$
	și care, chiar dacă nu are aplicabilitate în cazul de față, a condus la următorul rezultat:
	\item \textbf{Diferența Minkowski} a două mulțimi de puncte $A$ și $B$ este mulțimea
	$$ A \ominus B = \left\lbrace a - b\ |\ a \in A, b \in B \right\rbrace $$
	și are o proprietate remarcabilă. Mulțimile $A$ și $B$ se află în coliziune (au cel puțin un punct în comun) dacă $A \ominus B$ conține originea spațiului geometric. În plus, distanța dintre acestea, în cazul în care nu se intersectează, este:
	$$ \centering dist(A, B) = \min \left\lbrace \left\Vert a - b \right\Vert\ |\ a \in A, b \in B \right\rbrace = \min \left\lbrace \left\Vert c \right\Vert\ |\ c \in A \ominus B \right\rbrace $$
	\label{minkowski_difference}
	\item În geometrie, un \textbf{simplex} este o generalizare a noțiunii de triunghi în spații de dimensiune arbitrară. Simplex-urile întâlnite în cadrul algoritmilor de detecție a coliziunii sunt punctul, muchia, triunghiul și tetraedrul.
	\label{simplex}
	\item Fie un triunghi $T$ definit de vârfurile $r_1$, $r_2$ și $r_3$. Atunci, pentru orice punct $r$ din interiorul triunghiului, există o serie de numere reale $\lambda_1$, $\lambda_2$, $\lambda_3$ unice, astfel încât $\lambda_1 + \lambda_2 + \lambda_3 = 1$ și $r = \lambda_1 r_1 + \lambda_2 r_2 + \lambda_3 r_3$. Cele trei numere $\lambda_1$, $\lambda_2$, $\lambda_3$ se numesc \textbf{coordonatele baricentrice} ale punctului $r$ în raport cu triunghiul $T$.
	\label{barycentric_coordinates}
	\item \textbf{Tensorul de inerție} este o matrice $I$ care exprimă măsura prin care un corp se opune modificării stării sale de repaus relativ sau de mișcare de rotație uniformă la acțiunea unui moment al forței, pe fiecare dintre cele trei axe ale sistemului său de coordonate locale.
	\label{inertia_tensor}
	
\end{itemize}

\subsection{Detecție coliziuni}
Detecția coliziunilor se realizează de obicei în două etape: una \textbf{preliminară} (eng. \textit{broad phase}) și una \textbf{exactă} (eng. \textit{near phase}). Motivul este unul foarte simplu -- algoritmii folosiți în a doua etapă sunt semnificativ mai intensivi computațional decât cei din prima.

\subsubsection{Etapa preliminară}
Pentru prima fază, fiecare corp din simulare are atașat un \textbf{volum încadrator} sub forma unei primitive (în cazul 3D, de regulă sferă sau paralelipiped) care să îl cuprindă în întregime. Dacă 2 corpuri sunt în coliziune (se intersectează), atunci este sigur că și volumele lor încadratoare se întrepătrund. Testele de intersecție pentru primitive sunt ușor de implementat și computat.
Cele mai uzuale volume încadratoare sunt:
\begin{itemize}
	\item \textbf{Sfera încadratoare} (eng. \textit{bounding sphere}): este definită de o poziție și o rază. Testul de intersecție este banal: două sfere se intersectează dacă distanța dintre centrele lor este mai mică sau egală cu suma razelor. Este o soluție eficientă ca memorie și ca test de intersecție, dar este inexactă și conduce la multe verificări inutile în faza fină a detecției.
	\item \textbf{Axis-aligned bounding box} (AABB): este definit de o poziție și de lungimea paralelipipedului pe fiecare dintre cele 3 axe ale sistemului global de coordonate (uzual, se reține jumătatea lungimii fiecărei laturi). Testul de intersecție este din nou destul de banal - se verifică întrepătrunderea celor două AABB-uri pe fiecare dintre cele 3 axe. Este mai precis decât sfera încadratoare, dar dezavantajul este că trebuie recalculat de fiecare dată când corpul este rotit, astfel încât volumul să rămână minim.
	\item \textbf{Oriented bounding box} (OBB): este definit de o poziție, lungimile paralelipipedului pe fiecare dintre cele 3 axe ale sistemului de coordonate local obiectului și o orientare. Este asemănător unui AABB, dar în loc de axele sistemului global de coordonate, sunt folosite axele sistemului de coordonate locale ale obiectului. Astfel, atât timp cât obiectul nu este deformabil, el nu trebuie recalculat și este mai precis decât un AABB. Dezavantajul este că testul de intersecție devine mai complicat și se bazează pe aplicarea \textbf{Teoremei axei separatoare} (eng. \textit{SAT - Separating axis theorem}), descrisă \hyperref[SAT]{mai jos}, pentru 15 axe posibile de separare.
\end{itemize}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{pics/cap3_00.png}
	\label{fig:cap3_00}
	\caption[volume încadratoare uzuale]{sferă încadratoare, AABB, OBB}
\end{figure}
Până acum am acoperit doar coliziunea în cazul unei perechi de obiecte, însă în cadrul unei simulări pot exista un număr foarte mare de obiecte. Abordarea $O(n^2)$, de a verifica fiecare pereche de obiecte din scenă este ineficientă.

O posibilă soluție este aranjarea obiectelor într-un \textbf{arbore de volume încadratoare} (eng. \textit{bounding volume hierarchy})\label{BVH}\cite{ericson_bvh}, care să fie actualizat pe parcursul simulării (odată la una sau mai multe etape ale acesteia). Frunzele arborelui vor fi chiar obiectele individuale ale scenei, iar restul nodurilor vor constitui volumul minim care încadrează toate nodurile copii. Astfel, dacă arborele este menținut echilibrat, timpul de verificare a perechilor de obiecte devine logaritmic, întrucât nodurile copii nu trebuie verificate pentru coliziune dacă părinții lor nu se intersectează.

\label{bsp}
Un alt tip de arbori folosiți sunt cei care partiționează întreg spațiul scenei, pe baza unor plane alese astfel încât împărțirea obiectelor să fie cât mai uniformă. Exemple de astfel de arbori sunt \textbf{arborii BSP} (eng. \textit{binary space-partitioning tree})\cite{ericson_bsp} sau \textbf{octrees} (și variații ale acestora -- \textbf{quadtrees})\cite{ericson_octrees}.

\subsubsection{Etapa exactă}
A doua parte a detecției de coliziuni o consider ușor mai interesantă, deoarece este responsabilă de stabilirea \textbf{punctelor de coliziune}\label{punct_coliziune} dintre corpurile aflate în coliziune. Un exemplu de caracterizare a unui astfel de punct poate fi:
\begin{lstlisting}[style=myC++, label = {code:CollisionPointExample}]
struct CollisionPoint {
	vec3 positionA;    // pozitia celui mai adanc punct de interpenetrare
	vec3 positionB;    // in coordonatele locale ale fiecarui obiect
	vec3 normal;       // normala contactului (directia de separare)
	float penetration; // distanta de interpenetrare
	Obj *objA;         // pointer catre fiecare dintre obiecte, pentru a
	Obj *objB;         // accesa matricele de modelare, functii suport etc.
}
\end{lstlisting}
În acest scop, au fost definiți mai mulți algoritmi care preiau o pereche de obiecte și stabilesc definitiv dacă acestea se intersectează, \textbf{punctul cel mai adânc de interpenetrare}, \textbf{normala} (sau direcția de separare) și \textbf{distanța de penetrare} (sau de separare) în sine.


\textbf{Teorema axei separatoare} derivă din \textbf{teorema hiperplanului separator}\cite{sat}:
\begin{theorem}[Teorema hiperplanului separator]
	Dacă A și B sunt două submulțimi disjuncte nevide ale lui $\mathbb{R}^n$, atunci există $v\in\mathbb{R}^n, v\neq0, c\in\mathbb{R}$, astfel încât $v^{T}x\leq c, \forall x\in A$ și $v^{T}x\geq b, \forall x\in B.$
	\label{SAT}
\end{theorem}
Adaptată pentru cerințele noastre, ea ne spune că două corpuri se intersectează dacă nu există nicio axă pe care intervalele formate de proiecțiile punctelor celor două corpuri pe acea axă să se intersecteze.
\begin{figure}
	\centering
	\begin{subfigure}[th]{0.49\textwidth}
		\centering
		\includegraphics[width=\textwidth]{pics/cap3_01.eps}
		\label{fig:cap3_01}
		\caption{hiperplanul de separație $P$, axa separatoare $v$ și razele de proiecție $r_A$ și $r_B$ ale două corpuri care nu se intersectează}
		\vfill
	\end{subfigure}
	\hfill
	\begin{subfigure}[t]{0.49\textwidth}
		\centering
		\includegraphics[width=\textwidth]{pics/cap3_02.eps}
		\label{fig:cap3_02}
		\caption{o axă arbitrară $v$ și vectorul minim de translație $MTV$ (eng. \textit{minimum translation vector}) pentru această axă în cazul unei intersecții}
	\end{subfigure}
	\caption{Teorema axei separatoare}
\end{figure}
Astfel, două obiecte nu se intersectează (pe o axă) dacă suma razelor lor de proiecție este mai mică decât distanța dintre proiecțiile centrelor lor pe acea axă. În cazul poliedrelor convexe, intersecția poate fi de 3 tipuri: față-față, față-muchie, muchie-muchie (vârfurile pot fi considerate muchii degenerate) și este suficient să testăm doar următoarele posibile axe de separare:
\begin{itemize}
	\item axele paralele cu normalele fețelor obiectului A
	\item axele paralele cu normalele fețelor obiectului B
	\item axele paralele cu vectorii rezultați în urma produsului vectorial al tuturor muchiilor lui A cu toate muchiile lui B
\end{itemize}
Normala de coliziune este chiar axa care a rezultat într-o penetrare minimă, distanța de separare este chiar lungimea vectorului minim de translație ($min_B - max_A$ sau $min_A - max_B$), iar pentru determinarea punctelor de contact se vor calcula, pentru ambele obiecte, \hyperref[support_points]{punctele suport} în direcția de separare.


\textbf{Algoritmul Gilbert-Johnson-Keerthi} (GJK) este o altă metodă de a determina cu precizie dacă două obiecte se intersectează. A fost propus inițial în 1988\cite{gjk_original}, ca metodă de a determina distanța euclidiană între două mulțimi convexe din $\mathbb{R}^n$, iar o implementare eficientă și robustă a fost propusă de \textit{Gino van den Bergen} în 1998\cite{gjk_gino}.

\begin{algorithm}[H]
	\footnotesize
	\linespread{0.9}\selectfont
	\caption{Testul de intersecție Gilbert-Johnson-Keerthi}
	\label{gjk_intersection_test}
	\begin{algorithmic}[0]
		\Function {GJKTestIntersecție}{$forma\_A$, $forma\_B$, $directie\_initiala$}
			\State $punct\_nou \gets \textproc{Suport}(forma\_A, directie\_initiala) - \textproc{Suport}(forma\_B, -directie\_initiala)$
			\State $simplex \gets \left\lbrace punct\_nou \right\rbrace $
			\State $directie \gets -punct\_nou$
			\Loop
				\State $punct\_nou \gets \textproc{Suport}(forma\_A, directie) - \textproc{Suport}(forma\_B, -directie)$
				\If{$\textproc{produs\_scalar}(punct\_nou, directie) < 0$}
					\State \Return \textit{Fals}
				\EndIf
				\State $simplex \gets simplex\ \cup\ punct\_nou $
				\State $simplex, directie, contine\_originea \gets \textproc{ActualizeazăSimplex}(simplex) $
				\If{$contine\_originea$}
					\State \Return \textit{Adevărat}
				\EndIf
			\EndLoop
		\EndFunction
		\Statex
		\Function {ActualizeazăSimplex}{$simplex$}
			
			1. determină simplex-ul cel mai apropiat de origine care se poate forma din cât mai puține din punctele simplex-ului dat ca parametru
			
			2. direcția de căutare devine normala către origine a noului simplex
			
			3. în cazul tetraedru, întoarce True dacă simplex-ul conține originea
		\EndFunction
	\end{algorithmic}
\end{algorithm}

Practic, la fiecare iterație, \hyperref[simplex]{simplex-ul} încearcă să se extindă și să cuprindă originea, adăugând mereu un punct suport de pe \hyperref[minkowski_difference]{\textit{diferența Minkowski}} a celor două obiecte, aflat în direcția originii, până când aceasta este cuprinsă în simplex sau nu se mai apropie de acesta.



În cazul în care algoritmul \textit{GJK} a stabilit că există o coliziune, pentru determinarea normalei, distanței de penetrare și a punctelor de contact, \textbf{algoritmul EPA}\cite{epa_gino} (eng. \textit{expanding polytope algorithm}) poate fi folosit pentru determinarea \hyperref[punct_coliziune]{informațiilor de coliziune}. Acesta preia \hyperref[simplex]{simplex-ul} rezultat în urma aplicării \textit{GJK} și îl extinde iterativ cu \hyperref[support_points]{puncte suport} de pe frontiera \hyperref[minkowski_difference]{\textit{diferenței Minkowski}}, până când distanța minimă dintre politopul rezultat și origine nu se mai modifică. Odată întâlnită această situație, \hyperref[barycenric_coordinates]{coordonatele baricentrice} ale proiecției originii pe triunghiul (în cazul 3D) sau dreapta (în cazul 2D) cea mai apropiată de origine pot fi folosite pentru determinarea punctelor de coliziune, iar distanța de la origine la triunghi (sau dreaptă) este chiar distanța de penetrare și normala coliziunii. Expansiunea politopului se face prin divizarea feței celei mai apropiate și crearea de noi triunghiuri sau laturi folosind punctul nou ales și punctele rămase.

\begin{algorithm}[]
	\footnotesize
	\linespread{0.9}\selectfont
	\caption{Expanding Polytope Algorithm și determinarea punctelor de coliziune}
	\label{epa}
	\begin{algorithmic}[0]
		\Function {EPACreeazăPunctDeColiziune}{$forma\_A$, $forma\_B$, $simplex$}
			\State $ politop \gets simplex.lista\_triunghiuri $
			\Loop
				\State $ cel\_mai\_apropiat\_triunghi \gets \argmin_{tr} \textproc{distanța}(tr, origine), tr \in politop $
				\State $ distanta \gets \textproc{distanța}(cel\_mai\_apropiat\_triunghi, origine) $
				\State $ normala \gets cel\_mai\_apropiat\_triunghi.normala $
				\State $ punct\_nou \gets \textproc{Suport}(forma\_A, normala) - \textproc{Suport}(forma\_B, -normala) $
				\State $ distanta\_noua \gets \textproc{distanța}(punct\_nou, origine) $
				\If{$ distanta\_noua - distanta < prag $}
					\State $ coordonate \gets \textproc{CoordonateBaricentrice}(origine, cel\_mai\_apropiat\_triunghi) $
					
				\State	$ puncte\_coliziune \gets $ pentru fiecare obiect, se calculează punctul de coliziune în funcție de corespondențele fiecărui punct al triunghiului din mulțimea de puncte a obiectului respectiv
				\State \Return $ puncte\_coliziune, normala, distanta $
				\EndIf
				\State $ politop \gets politop \setminus \left\lbrace cel\_mai\_apropiat\_triunghi \right\rbrace $
				\State creează triunghiuri noi folosind $ punct\_nou $ în spațiul lăsat descoperit
			\EndLoop
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\subsection{Rezolvare coliziuni}
În esență, rezolvarea coliziunilor implică aplicarea unui \textbf{răspuns} asupra corpurilor aflate în contact, care să conducă la separarea acestora. În lumea reală, răspunsul vine sub forma forțelor elastice care se opun comprimării (oricât de mică ar fi aceasta) corpurilor aflate în contact, determinând o accelerație care reduce viteza de ciocnire până la valori negative, când corpurile se separă. În cadrul unui motor de fizică, acest fenomen este simulat cu ajutorul \textbf{impulsurilor} -- modificări bruște a vitezelor obiectelor aflate în coliziune, astfel încât acestea să tindă spre separare. În general, sunt suficiente două impulsuri -- cel liniar și cel unghiular, fiecare modificând viteza corespondentă.

Soluționarea unei coliziuni este de regulă realizată cu ajutorul conceptului mult mai general de \textbf{constrângeri fizice}, definite ca o serie de ecuații și inecuații care trebuie să fie satisfăcute. În cazul rezolvării unei coliziuni, constrângerea care trebuie satisfăcută de vitezele celor două corpuri este:
$$ \dot{C} \colon \left( -\vec{V_A} - \vec{\omega_A} \times \vec{r_A} + \vec{V_B} + \vec{\omega_B} \times \vec{r_B} \right) \cdot \vec{n} + b\geq 0 $$unde:
\begin{itemize}
	\item $\vec{V_A}, \vec{V_B}$ sunt vitezele liniare ale celor două corpuri
	\item $\vec{\omega_A}, \vec{\omega_B}$ sunt vitezele unghiulare ale celor două corpuri
	\item $\vec{r_A}, \vec{r_B}$ sunt definite ca $P_A - C_A$ și $P_B - C_B$, cu $P_A,P_B$ punctele cele mai adânci de interpenetrare și $C_A, C_B$ centrele de masă ale corpurilor
	\item $\vec{n}$ este normala contactului
	\item $b$ este un termen de bias, care corespunde vitezei de separare a celor două corpuri și este influențat de coeficientul de restituire al ciocnirii: $$b = C_R\left( -\vec{V_A} - \vec{\omega_A} \times \vec{r_A} + \vec{V_B} + \vec{\omega_B} \times \vec{r_B} \right) \cdot \vec{n} $$
\end{itemize}

Formula completă pentru determinarea impulsului normal $\vec{j_n}$ necesar rezolvării vitezei unui corp după coliziune este:

$$ \vec{j_n} = \frac{\left(-1 + C_R\right) \cdot \left( \vec{V_B} - \vec{V_A} + \vec{\omega_B} \times \vec{r_B} - \vec{\omega_A} \times \vec{r_B} \right) }{\left(\frac{1}{m_A} + \frac{1}{m_B} \right) + \left(\left( \vec{r_A} \times \vec{n} \right) \cdot \left( I_{A}^{-1} * \left(\vec{r_A} \times \vec{n}\right)\right) + \left( \vec{r_B} \times \vec{n} \right) \cdot \left( I_{B}^{-1} * \left(\vec{r_B} \times \vec{n}\right)\right)  \right)} * \vec{n} $$

unde:
\begin{itemize}
	\item $m_A$, respectiv $m_B$ sunt masele celor două corpuri
	\item $I_{A}$, respectiv $I_{B}$ sunt tensorii de inerție în coordonate din spațiul lume pentru cele două corpuri
\end{itemize}

Frecările sunt rezolvate sub forma unor \textbf{impulsuri tangențiale}, care vor modifica viteza corpurilor în două direcții perpendiculare pe normala de contact, în plus față de \textbf{impulsul normal}.

$$ \vec{j_{t_1}} = \frac{\left(-1 + C_R\right) \cdot \left( \vec{V_B} - \vec{V_A} + \vec{\omega_B} \times \vec{r_B} - \vec{\omega_A} \times \vec{r_B} \right) }{\left(\frac{1}{m_A} + \frac{1}{m_B} \right) + \left(\left( \vec{r_A} \times \vec{t_1} \right) \cdot \left( I_{A}^{-1} * \left(\vec{r_A} \times \vec{t_1}\right)\right) + \left( \vec{r_B} \times \vec{t_1} \right) \cdot \left( I_{B}^{-1} * \left(\vec{r_B} \times \vec{t_1}\right)\right)  \right)} * \vec{t_1} $$

$$ \vec{j_{t_2}} = \frac{\left(-1 + C_R\right) \cdot \left( \vec{V_B} - \vec{V_A} + \vec{\omega_B} \times \vec{r_B} - \vec{\omega_A} \times \vec{r_B} \right) }{\left(\frac{1}{m_A} + \frac{1}{m_B} \right) + \left(\left( \vec{r_A} \times \vec{t_2} \right) \cdot \left( I_{A}^{-1} * \left(\vec{r_A} \times \vec{t_2}\right)\right) + \left( \vec{r_B} \times \vec{t_2} \right) \cdot \left( I_{B}^{-1} * \left(\vec{r_B} \times \vec{t_2}\right)\right)  \right)} * \vec{t_2} $$

O derivare a formulelor de mai sus poate fi urmărită în prezentarea lui \textit{Erin Catto}\cite{constraints_catto}.


O simulare va conține un număr mare de contacte, care se pot afecta unele pe altele (de ex. în cazul unei stive de obiecte), motiv pentru care rezolvarea acestora se face iterativ, până la convergență. Astfel, dacă rezolvarea unui contact va afecta un altul (este modificată distanța de penetrare, normala sau viteza de întâlnire), acest lucru se va reflecta în iterațiile succesive și sistemul poate găsi soluția corectă. În realitate, într-o simulare, acest lucru se întâmplă destul de rar, dar rezultatele obținute sunt satisfăcătoare, imperfecțiunile fiind neglijabile.

Realistic vorbind, o coliziune este deseori formată din mai multe puncte de contact, care împreună formează un \textbf{manifold} care trebuie rezolvat.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{pics/cap3_03.png}
	\label{fig:cap3_03}
	\caption[]{3 cazuri de contact și manifold-urile lor}
\end{figure}
În acest scop, există 2 posibile abordări \cite{eberly_collision_response}:
\begin{enumerate}
	\item \textbf{Metoda impulsurilor secvențiale}\label{seq_impulse_method} -- impulsurile sunt calculate și aplicate iterativ în fiecare dintre punctele de contact.
	\item \textbf{Metoda contactelor simultane} -- Jacobian-ul folosit pentru calculul impulsurilor este determinat pe baza tuturor punctelor din manifold-ul de contact, iar impulsurile sunt aplicate o singură dată per manifold.
\end{enumerate}

În plus ar trebui menționat faptul că impulsurile descrise mai sus sunt menite doar să oprească întrepătrunderea corpurilor, și nu să le și separe efectiv. Pentru acest lucru există mai multe alternative\cite{catto_position_correction}:
\begin{enumerate}
	\item \textbf{Stabilizarea Baumgarte} -- presupune adăugarea unei părți a distanței de penetrare la termenul de bias din formula pentru determinarea impulsului
	\item \textbf{Metoda pseudo-vitezelor}\label{pseudo_velocities} -- constă în rezolvarea vitezelor corpurilor aflate în coliziune, recalcularea distanței de penetrare, a vitezelor și a maselor și mai apoi aplicarea unei corecții asupra pozițiilor celor două corpuri într-un pas ulterior.
	\item \textbf{Metoda Gauss-Seidel neliniară} -- este asemănătoare cu metoda pseudo-vitezelor, dar presupune recalcularea interpenetrării după fiecare punct de contact rezolvat
\end{enumerate}
\subsection{Integrare numerică}
Într-un motor de fizică, etapa de integrare constă în actualizarea stării obiectelor, prin \textbf{integrarea în raport cu timpul} a mărimilor fizice derivate. Accelerația unui corp este dată de formula $ a = \frac{F}{m} $, unde $F$ este rezultanta forțelor care acționează asupra corpului și $m$ este masa acestuia. Într-o simulare, accelerația este considerată o mărime fizică primară și este cea dintâi calculată în fiecare cadru. Accelerația este totodată definită și ca variația vitezei în timp, iar viteza este variația poziției în timp, ceea ce ne permite să calculăm atât viteza $\dot{p}'$, cât și poziția $p'$, prin integrarea accelerației $\ddot{p}$, respectiv vitezei $\dot{p}$:
$$ \dot{p}' = \dot{p} + \ddot{p}t $$
$$ p' = p + \dot{p}t + \ddot{p}\frac{t^2}{2} \approx p + \dot{p}t $$
Deoarece într-o simulare avem de-a face cu momente discrete de timp(dictate de diferența de timp dintre două cadre -- \textbf{deltaTime}, aceste valori trebuie aproximate, de unde rezultă nevoia folosirii unor metode de integrare numerică cu pas de timp discret.
Se disting o serie de metode, mai mult sau mai puțin precise \cite{integration_gaffer}:
\begin{itemize}
	\item \textbf{Metoda Euler explicită}\cite{explicit_euler} presupune determinarea, în ordine, mai întâi a noii poziții și apoi a noii viteze, dar are dezavantajul că pierde din precizie dacă există variații mari ale mărimilor de la un cadru la altul, cu eroare de ordinul $O(deltaTime)$
	\begin{lstlisting}[style=myC++]
		position = position + velocity * deltaTime;
		velocity = velocity + acceleration * deltaTime;
	\end{lstlisting}
	\item \textbf{Metoda Euler semi-implicită}\cite{implicit_euler}\label{inline_implicit_euler} presupune folosirea noii viteze la determinarea noii poziții și este considerabil mai precisă, cu eroare de ordinul $O(deltaTime^2)$
	\begin{lstlisting}[style=myC++]
	velocity = velocity + acceleration * deltaTime;
	position = position + velocity * deltaTime;
	\end{lstlisting}
	\item \textbf{Metoda Runge-Kutta 4}\cite{runge_kutta} evaluează derivata stării în 4 puncte diferite din cadrul intervalului de derivare, folosind ca feedback rezultatele anterioare și este mult mai precisă, ceea ce conduce la o eroare de ordinul $O(deltaTime^4)$
\end{itemize}

\subsection{Interfață grafică}
Soluțiile pentru implementarea unei \textbf{interfețe grafice cu utilizatorul} (eng. \textit{graphical user interface - GUI}) sunt întâlnite sub forma unor biblioteci care oferă API-uri programatorilor care doresc să le folosească în proiectele lor. Astfel de biblioteci există în număr destul de mare, iar facilitățile oferite de fiecare variază -- de la colecții de widget-uri minimale până la întregi framework-uri pentru dezvoltare de aplicații complete, care  oferă instrumente și funcționalități deja implementate care acoperă o multitudine de scenarii de utilizare. O posibilă clasificare a interfețelor grafice este cea bazată pe proprietatea  de a reține scena desenată (GUI-ul în sine) de la un cadru la altul. Se disting, astfel:
\begin{enumerate}
	\item \textbf{Interfețele grafice persistente} (eng. \textit{retained mode GUIs}) sunt caracterizate de menținerea unui model intern(de obicei, o ierarhie de obiecte) al interfeței în memorie. Astfel, apelurile de API doar modifică starea acestui model, fără să conducă neapărat la desenarea elementelor. Biblioteca poate, prin urmare, să optimizeze randarea interfeței pe ecran, sau să mențină stări anterioare la care se poate reveni. Sunt soluții robuste, eficiente, rapide, dar necesită un timp mai îndelungat de familiarizare și de învățare a acestora. Exemple includ:
	\begin{itemize}
		\item \textbf{Windows Presentation Foundation}\cite{wpf} este un framework pentru dezvoltarea de aplicații client pentru sistemul de operare \textit{Windows}. Este un subset al framework-ului \textit{.NET} și utilizează un limbaj de tip Markup(i.e. \textit{XAML}) pentru a oferi un model declarativ de programare. Asigură facilități de desenare (folosind \textit{Direct3D}), șabloane, animații, documente, securitate etc.
		\item \textbf{Qt}\cite{qt} este un alt framework complet pentru dezvoltare de aplicații cross-platform. Este aproape în întregime open source și este scris în C++. Oferă, printre altele, un mediu de dezvoltare complet (\textit{QtCreator}), un limbaj declarativ (\textit{QML}) pentru prototipare, suport pentru lucrul cu baze de date \textbf{SQL}, parsare de documente \textit{XML} sau \textit{JSON}, multithreading etc. Ar trebui menționată și documentația foarte bine pusă la punct și comunitatea imensă de utilizatori.
		\item \textbf{wxWidgets}\cite{wxwidgets} constă într-un API ușor de folosit pentru scrierea de aplicații grafice pe multiple platforme. Folosește controlul și utilitățile native platformei pentru care se dezvoltă aplicația, este în întregime open source și scris în C++ standard, cu multiple binding-uri pentru alte limbaje de programare populare. Oferă multiple componente grafice -- de la un simplu buton până la o fereastră pentru previzualizarea documentelor printate -- și sisteme pentru aranjarea elementelor, evenimente, integrare cu motorul de randare HTML nativ, tratare de erori, multithreading etc.
	\end{itemize} 
	\item De cealaltă parte, \textbf{interfețele grafice imediate} (eng. \textit{immediate mode GUIs}) lasă aproape totul la îndemâna utilizatorului(tratarea evenimentelor, management-ul resurselor). Elementele sunt desenate imediat pe ecran și nu mai există o delimitare clară a logicii aplicației de elementele de interfață. Sunt considerabil mai simple, dar mai ușor de extins și de modificat și sunt utile mai ales pentru prototipare, dar și în cazurile în care interfața grafică nu reprezintă o parte centrală a aplicației (de ex. jocuri). Pot fi amintite:
	\begin{itemize}
		\item \textbf{Dear ImGui}\cite{imgui} este o bibliotecă rapidă, portabilă, și independentă de motorul de randare. A fost dezvoltată pentru C++, nu conține dependințe externe, este open source și se concentrează pe simplitate și productivitate. Se pretează mai ales integrării în game engine-uri, tool-uri pentru vizualizare sau pentru debugging. Conține o multitudine de widget-uri și elemente anexe, care pot fi desenate pe loc, oriunde în aplicație, pentru a obține o strânsă legătură cu logica acesteia.
		\item \textbf{Nuklear}\cite{nuklear} este un toolkit minimal pentru dezvoltarea de GUI-uri, scris în ANSI C și open source. A fost proiectat să poată fi ușor de integrat în aplicații și constă dintr-un singur fișier header. Are o amprentă redusă asupra memoriei, este personalizabilă și se concentrează strict pe elementele de interfață.
	\end{itemize}
\end{enumerate}

\section{Alegeri pentru lucrarea de față}

Dintre soluțiile menționate în subsecțiunile de mai sus, am fost nevoit să fac niște alegeri, pe care urmează să le prezint și să le motivez în continuare.

\subsection{Detecție coliziuni}

Deoarece scenele cu care am testat simulatorul sunt de dimensiuni relativ mici (sub 100 de obiecte), am decis că o ierarhie de volume încadratoare nu aduce o îmbunătățire semnificativă în raport cu overhead-ul pe care l-ar aduce etapei de implementare a soluției. La fel, o partiționare a spațiului scenei în arbori, utilizând \hyperref[bsp]{\textit{BSP}}, mi s-a considerat nejustificată. Astfel, m-am folosit doar de un \textbf{detector $O(n^2)$}, care testează intersecția dintre \textbf{OBB-urile} obiectelor folosind \hyperref[SAT]{\textbf{Teorema axei separatoare}}.

Pentru că obiectele din scenă sunt doar corpuri geometrice elementare pentru care nu stochez liste de vârfuri, muchii și fețe, ci doar descrierea geometrică a formei acestora, Teorema axei separatoare nu se pretează pentru determinarea punctelor de contact. În plus, corpurile rotunde (cilindru, con, sferă, capsulă) ar pune probleme în realizarea testului de separare, deoarece ar avea nevoie de un număr foarte mare de axe care să fie testate. În schimb, am ales să utilizez \hyperref[gjk_intersection_test]{\textbf{algoritmul GJK}}, care se poate folosi de descrierea geometrică a formei corpurilor pentru calculul facil al punctelor de suport necesare la determinarea simplex-ului final.

Deoarece rezultatul algoritmului \textit{GJK} poate fi utilizat ca intrare pentru \hyperref[epa]{\textbf{EPA}}, am folosit acest algoritm în determinarea punctelor de coliziune.

\subsection{Rezolvare coliziuni}

Complexitatea pe care ar fi adus-o implementarea metodei rezolvării simultane a contactelor nu este justificată în cazul de față. Ar fi fost nevoie de un redesign al structurilor de date folosite adus de necesitatea operațiilor dintre matrice și vectori de dimensiuni mari, direct proporționale cu numărul de contacte din manifold -- ar fi trebuit să îmi scriu propria implementare pentru structurile geometrice de date - vectori și matrice de dimensiuni mai mari decât 4x4. Am ales, astfel, să utilizez \hyperref[seq_impulse_method]{\textbf{metoda impulsurilor secvențiale}}, care produce rezultate acceptabile pentru o simulare care nu se vrea a fi hiper-exactă. Corectarea pozițiilor corpurilor o realizez printr-o metodă asemănătoare cu cea a \textbf{pseudo-vitezelor}.

De asemenea, am decis să nu generalizez contactele la constrângeri fizice și am ales să introduc în schimb alte optimizări, descrise în capitolele ulterioare.

\subsection{Integrare numerică}

În cazul unei simulări, metoda Euler explicită este inferioară din toate punctele de vedere celei \textbf{Euler implicite}, iar precizia altor metode de ordin superior ar fi combătută oricum de micile imperfecțiuni apărute în urma rezolvării coliziunilor. Am ales să păstrez lucrurile simple și să folosesc a doua metodă menționată mai sus.

\subsection{Interfață grafică}

Pentru realizarea interfeței grafice, lipsa de experiență în lucrul cu tool-uri consacrate ca \textit{Qt} sau \textit{WPF} m-au făcut să aleg să folosesc o soluție imediată, care să fie ușor de învățat și de utilizat. Documentația \textbf{Dear ImGui} mi s-a părut mai bine realizată și multitudinea de widget-uri și addon-uri deja existente au contribuit la alegerea făcută. Rapiditatea cu care am putut implementa o interfață grafică completă și funcțională m-a surprins plăcut și consider alegerea ca fiind una inspirată.
% 
%\dezvoltare Ce soluții similare există pe piață? Care sunt limitările lor / pentru ce cazuri de utilizare sau pentru ce tip de clienți produsele existente pe piață nu răspund cerințelor? Care sunt indicatorii pe baza cărora sunt evaluate aceste produse, de către potențiali clienți, și unde sunt lipsurile/ care este oportunitatea generată de lipsurile acestea?
%
%\cercetare Metode existente (sau ``State of the Art'') se referă, de regulă, la nivelul curent de dezvoltare: care este starea curentă a domeniului, unde ne găsim, care este contextul. Care sunt soluțiile actuale prezente în literatura de specialitate și care sunt limitările lor? Ce direcții de explorare sunt recomandate în literatura de specialitate? Literatura de specialitate se refera la articole științifice recente, publicate în reviste cu factor de impact mare, sau în volumele unor conferințe de top, sau în cărți.
%
%\ambele În încheierea acestui capitol se dorește descrierea tehnologiilor folosite în lucrare, cu alternative și cu argumente convingătoare calitative și cantitative.  
%
%Criterii pentru calificativul \textit{Ne\textit{Satisfăcător}}: 
%\begin{itemize}
%	\item \dezvoltare Sunt analizate superficial câteva produse de pe piață; 
%	\item \cercetare analiza literaturii limitata la grupuri de cercetare din România;
%	\item \ambele Sunt descrise tehnologiile folosite în lucrare. 
%\end{itemize}
%
%Criterii pentru calificativul \textit{Satisfăcător}:
%\begin{itemize}
%	\item \dezvoltare Există un interviu, un client, analiza cerințelor este elaborată pe baza interviului.
%	\item \cercetare analiza literaturii de specialitate din lume, fără poziționarea precisă a lucrării în peisajului domeniului studiat;
%	\item \ambele Sunt descrise câteva tehnologii alternative pentru fiecare din tehnologiile folosite în lucrare. Există o argumentare referitoare la alegere.
%\end{itemize}
%
%Criterii pentru calificativul \textit{Bine}:
%\begin{itemize}
%	\item \dezvoltare Proces iterativ pe baza unor interviuri cu mai mulți clienți, dezvoltare MVP, reevaluare cerințe;
%	\item \cercetare analiza literaturii de specialitate din lume, cu poziționarea precisă a lucrării în peisajul actual al domeniului studiat; 
%	\item \ambele Sunt descrise tehnologii alternative. Sunt analizate cantitativ și calitativ, folosite benchmarkuri și teste efectuate de student. Analiza este rezumată prin tabele și grafice.
%\end{itemize}
%
%\section{Indicații formatare figuri}
%
%Figurile utilizate în document vor fi centrate și numerotate (de exemplu Figura~\ref{fig:pic1}). 
%Orice figură ce nu este realizată de către autorul lucrării va fi în mod obligatoriu citată fie la final (de exemplu Figura ~\ref{fig:pic2} este preluată din documentul \cite{}), fie cel puțin într-o notă de subsol (a se vedea Figura~\ref{fig:pic2}). Orice figură ce depășește ca dimensiune 50\% dintr-o pagină, va fi mutată la anexe. Toate figurile din cadrul tezei vor fi referite în text. Exemplu: Figura~\ref{fig:pic1} prezintă o schemă de principiu pentru un amplificator inversor cu AO. 
%
%\begin{figure}[th]
%\centering
%\includegraphics{pics/Pic1.png}
%  \caption{Amplificator inversor}
%  \label{fig:pic1}
%\end{figure}
%
%\newpage
%
%\begin{figure}[th]
%\centering
%\includegraphics{pics/Pic2.png}
%  \caption[Amplificator de instrumentație cu 3 AO-uri]{Amplificator de instrumentație cu 3 AO-uri\protect\footnotemark}
%  \label{fig:pic2}
%\end{figure}
%\footnotetext{© http://www.ece.tamu.edu/sspalermo/ecen3205/Secton\%201III.pdf}

\chapter{Soluția Propusă}

Soluția propusă urmărește arhitectura firească a unei aplicații grafice \textbf{OpenGL}, cu următoarele componente:
\begin{enumerate}
	\item \textbf{backend}-ul -- este un framework care oferă funcționalitățile de bază necesare funcționării aplicației \textit{OpenGL}
	\item \textbf{logica} -- este implementarea propriu-zisă a simulatorului de interacțiuni fizice
	\item \textbf{frontend}-ul -- reprezintă interfața cu utilizatorul
\end{enumerate}

\section{Backend-ul}

Funcționalitățile pe care le oferă așa-numitul backend sunt:
\begin{itemize}
	\item crearea, controlul și interfațarea cu un context \textit{OpenGL}
	\item suport pentru încărcarea de mesh-uri 3D
	\item suport pentru definirea și încărcarea de shader-e \textit{OpenGL}
	\item crearea și controlul unei ferestre de afișare
	\item oferirea unui model generic pentru scrierea de aplicații \textit{OpenGL}:
		\begin{itemize}
			\item control pentru fereastra de afișare
			\item management-ul input-ului de la mouse și tastatură
			\item implementarea unei camere first-person pentru vizualizarea scenei
			\item o scenă de bază care poate fi moștenită și căreia i se vor adăuga funcționalitățile specifice aplicației
			\item interfață pentru desenarea mesh-urilor 3D
		\end{itemize}
\end{itemize}
Lista de mai sus nu este exhaustivă, complexitatea unui astfel de framework, chiar și minimal, este destul de mare. Cum implementarea acestuia nu a făcut parte din obiectivele proiectului, am ales să folosesc framework-ul\cite{framework_egc_github} oferit pentru laboratoarele aferente cursului de Elemente de Grafică pe Calculator, din cadrul secției CTI a Universității Politehnica București. O descriere mai detaliată a acestuia poate fi găsită pe wiki-ul asociat laboratorului\cite{framework_egc_ocw}.

Astfel, etapele funcționării unei aplicații, facilitate de framework-ul descris mai sus sunt:
\begin{enumerate}
	\item Se definesc proprietățile pentru fereastra de lucru.
	\item Se inițializează API-ul \textit{OpenGL}.
	\item Se creează fereastra de lucru cu un context \textit{OpenGL}.
	\item Se atașează evenimentele de fereastră la motorul care se ocupă de tratarea lor.
	\item Se creează și se inițializează noua scenă 3D.
	\item Se pornește bucla principală a aplicației.
\end{enumerate}

\section{Logica aplicației}

Este componenta centrală a oricărei aplicații grafice și funcționează în întregime în cadrul buclei principale de program.

\subsection{Funcționare}
Într-o iterație au loc următorii pași:
\begin{enumerate}
	\setcounter{enumi}{-1}
	\item Backend-ul realizează un preambul în care își actualizează parametrii interni
	\begin{itemize}
		\item Se pregătește contextul \textit{OpenGL} pentru desenare -- sunt curățate buffer-ele de culoare, dimensiunea ferestrei de desenare este reactualizată, dacă este cazul
		\item Se estimează timpul de execuție pentru iterația actuală, pe baza duratei iterației precedente (\textit{deltaTime}).
		\item Sunt procesate evenimentele salvate anterior.
	\end{itemize}
	\item Este desenată scena în totalitate.
	\item Se actualizează starea obiectelor din simulare, prin efectuarea pasului de integrare.
	\item Se efectuează faza preliminară a detecției de coliziuni -- se obține o listă de perechi de obiecte posibil aflate în contact.
	\item Se efectuează faza exactă a detecției de coliziuni -- lista de mai sus este prelucrată și sunt actualizate vechile contacte, în cazul perechilor de obiecte aflate în coliziune continuă, sau sunt generate altele noi.
	\item Se încearcă, iterativ, rezolvarea tuturor contactelor din scenă.
	\item Se face trecerea la următorul cadru -- se revine la pasul 0.
\end{enumerate}
\begin{itemize}
	\item Pentru a nu bloca execuția simulării, toate evenimentele de input sau de control al ferestrei sunt salvate de backend într-un buffer, pentru a putea fi soluționate toate deodată în pasul 0.
\end{itemize}

\subsection{Structură}
În continuare voi descrie, pe rând, componentele individuale ale simulatorului.

\subsubsection{Obiectele scenei}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\linewidth]{pics/cap4_00.eps}
	\label{fig:physicsObject}
	\caption[]{Descrierea unui obiect al scenei}
\end{figure}

Începând cu \textbf{obiectele scenei}, acestea sunt alocate dinamic la rularea aplicației și stochează informații necesare la desenare, dar oferă și o interfață pentru actualizarea corpului solid, prin metoda \textbf{update()}. Am ales să folosesc obiectul scenei ca pe o scurtătură către toate referințele necesare celorlalte componente (de ex. în cadrul algoritmului GJK, determinarea punctului de suport pe \hyperref[minkowski_difference]{\textit{diferența Minkowski}} a 2 corpuri necesită apelul metodei \textit{getSupportPtInLocalSpace()} din clasa \textit{Shape} și poate fi accesată prin referința din \textit{PhysicsObject}).

Toate obiectele scenei sunt menținute într-un obiect de tip \textbf{ObjectSpawner} care se ocupă de instanțierea și actualizarea lor și oferă funcționalități de nivel înalt aplicației.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{pics/ObjectSpawner.eps}
	\caption[]{Structura unui obiect ObjectSpawner}
	\label{fig:ObjectSpawner}
\end{figure}

\subsubsection{Corpurile solide}
Starea cinematică a obiectului este încapsulată într-un obiect \textbf{RigidBody}(descris în întregime în [\autoref{fig:RigidBody}]). Pasul de integrare presupune:
\begin{enumerate}
	\item \textbf{determinarea accelerației} ca rezultat al forțelor care acționează asupra obiectului
	\item determinarea noilor valori pentru \textbf{viteză} (atât liniară, cât și unghiulară), și pentru \textbf{poziție}, respectiv \textbf{orientare}, folosind \hyperref[inline_implicit_euler]{\textit{metoda Euler semi-implicită}}
	\item sunt simulate forțele de frecare cu aerul, prin înmulțirea vitezelor cu un \textbf{factor de amortizare}
	\item sunt actualizate \textbf{matricele de modelare} și \textbf{tensorul de inerție} și se resetează acumulatorii de forțe și momente 
\end{enumerate}

\subsubsection{Detecția de coliziuni}
Mai departe, controlul aplicației este preluat de \textbf{detectorul de coliziuni}, a cărui structură completă poate fi găsită în [\autoref{fig:CollisionDetection}].

\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\linewidth]{pics/CollisionDetectionSmall.eps}
	\caption[]{Subsistemul de detecție de coliziuni}
	\label{fig:CollisionDetectionSmall}
\end{figure}

Am considerat necesară separarea procesului de detecție a coliziunilor în două subsisteme -- \textbf{detectorul de posibile coliziuni}, corespondent fazei preliminare a algoritmului și \textbf{generatorul de puncte de coliziune}, care preia responsabilitatea pentru corpurile descoperite de primul. \textbf{Generatorul de coliziuni} nu este decât un agregator al celor două subsisteme care oferă o interfață simplă aplicației.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{pics/collider.eps}
	\caption[]{OBBCollider implementează clasa abstractă Collider}
	\label{fig:collider}
\end{figure}

Detectorul de posibile coliziuni menține un \textbf{vector de collider-e OBB} pentru obiectele din scenă pentru care se dorește posibilă existența coliziunilor și construiește \textbf{vectorul de posibile coliziuni} folosind referințele către obiectele fizice din collider-e. Generatorul de puncte de coliziune preia rezultatul și efectuează, mai întâi testul de intersecție, și mai apoi calculează punctele de coliziune, care este rezultatul final al etapei de detecție a coliziunilor și care este transmis mai departe în pipeline \textbf{rezolvitorului de coliziuni}, a cărui structură completă poate fi observată în [\autoref{fig:CollisionResolution}].
\subsubsection{Rezolvarea coliziunilor}
Deoarece \textbf{punctele de coliziune} reprezintă doar niște informații legate de coliziunea cea mai adâncă dintre 2 corpuri (câte un singur punct pe suprafețele celor două corpuri, normala și distanța de penetrare) și ar fi ineficient să se aloce dinamic noi contacte la fiecare cadru, am folosit o schemă de caching bazată pe ideea de \textbf{contacte persistente} și \textbf{manifold-uri de contact}:
\begin{itemize}
	\item introduc aici noțiunea de \textbf{punct de contact}, care pe lângă informațiile de coliziune, mai include și alte câmpuri necesare algoritmului de caching sau rezolvării în sine
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.85\linewidth]{pics/collisionContact.eps}
		\caption[]{\centering diferența dintre punctul de coliziune și punctul de contact \newline (a se observa că Contact moștenește CollisionPoint)}
		\label{fig:collisionContact}
	\end{figure}
	\item pentru fiecare pereche de obiecte pentru care există coliziune, punctele de contact sunt reținute într-un manifold format din maxim 4 astfel de puncte
	\item de fiecare dată când obțin un nou punct de coliziune între două obiecte, caut manifold-ul de contact asociat perechii de obiecte și îl actualizez:
	\begin{itemize}
		\item dacă nu am găsit un manifold pentru perechea curentă, atunci creez unul nou și creez un nou punct de contact pe care îl adaug la manifold
		\item dacă punctul de coliziune poate fi atribuit unuia dintre punctele de contact ale manifold-ului (se află la o distanță suficient de mică), atunci doar actualizez punctul de contact deja existent
		\item dacă nu corespunde unui astfel de punct, atunci este creat un nou punct de contact și este adăugat manifold-ului, înlocuind, dacă există deja 4 puncte, punctul de contact care oferă cea mai puțină informație (cel cu penetrarea cea mai mică)
	\end{itemize}
	\item manifold-urile care nu au fost actualizate în cadrul curent, sau cele formate din puncte de contact cu penetrare negativă, sunt pur și simplu eliminate din sistem
\end{itemize}

\begin{figure}[H]
	\centering
	\makebox[\textwidth][c]{\includegraphics[width=0.8\linewidth]{pics/CollisionResolutionSmall.eps}}
	\caption[]{Subsistemul de rezolvare a coliziunilor}
	\label{fig:CollisionResolutionSmall}
\end{figure}

Rezolvarea completă a coliziunilor presupune rezolvarea tuturor manifold-urilor de contact. La nivelul unui singur manifold au loc următorii pași:
\begin{enumerate}
	\item identificarea celui mai adânc contact (cu distanța de penetrare cea mai mare)
	\item rezolvarea erorii de poziție a corpurilor pe baza informațiilor acestui contact
	\item repetarea pașilor 1 și 2 cât timp iterațiile pentru rezolvarea pozițiilor nu sunt epuizate
	\item identificarea celui mai rapid contact (cu viteza de separare (!valoare negativă) cea mai mică)
	\item rezolvarea vitezelor corpurilor pe baza informațiilor acestui contact
	\item repetarea pașilor 4 și 5 cât timp iterațiile pentru rezolvarea vitezelor nu sunt epuizate
\end{enumerate}

\section{Interfața cu utilizatorul}
Posibilitatea utilizatorului de a interacționa cu simularea este oferită de o interfață minimală. Aceasta este bazată atât pe input-ul de la mouse și tastatură, cât și pe un GUI care să ofere control mai fin asupra parametrilor.

Astfel, utilizatorul poate selecta câte un obiect de pe ecran dând click pe acesta și îi poate controla poziția și orientarea folosind tastatura. În plus, controlul camerei oferite de backend se realizează tot cu ajutorul tastaturii, atunci când butonul dreapta al mouse-ului este ținut apăsat. Totodată, utilizatorul poate introduce oricând dorește obiecte noi în scenă, atât static, la inițializare, cât și dinamic, în timpul rulării aplicației.

Interfața grafică oferă posibilitatea de a controla în timp real parametrii simulării (elementele desenate, gravitația, numărul de iterații în cadrul diferiților algoritmi, precizie etc.). Utilizatorul primește feedback în timp real, valorile fiind în permanență afișate. În plus față de setările ce țin de simulare, mai pot fi alterate proprietățile (masă, poziție, orientare, coeficienți de frecare / elasticitate etc.) obiectului selectat cu mouse-ul.

În ultimul rând, pentru a putea testa și crea diferite simulări într-un mod cât mai facil, există posibilitatea de a încărca scene (formate din parametrii de simulare și lista cu obiectele din scenă) definite în fișiere \textit{.json} sau de a salva starea actuală a simulării într-o nouă astfel de scenă.

%Capitolul conține o privire de ansamblu a soluției ce rezolvă problema, prin prezentarea structurii / arhitecturii acesteia. În funcție de tipul lucrării acest capitol poate conține diagrame (clase, distribuție, workflow, entitate-relație), demonstrații de corectitudine pentru algoritmii propuși de autor, abordări teoretice (modelare matematică), structura hardware, arhitectura aplicației.
%
%
%Criterii pentru calificativul \textit{Ne\textit{Satisfăcător}}: 
%\begin{itemize}
%	\item	Descriere în limbaj natural.
%\end{itemize}
%
%Criterii pentru calificativul \textit{Satisfăcător}: 
%\begin{itemize}
%	\item	Descriere + diagrame de baze de date, workflow, clase, algoritmi. 
%\end{itemize}
%
%Criterii pentru calificativul \textit{Bine}: 
%\begin{itemize}
%	\item 	Descriere + diagrame de baze de date, workflow, clase, algoritmi + descrierea unui proces prin care s-a realizat arhitectura/structura soluției.
%\end{itemize}
%
%\section{Indicații formatare formule}
%Formulele matematice utilizate în document vor fi centrate în pagină și numerotate. 
%
%\begin{equation}
%(x+a)^n = \sum_{k=0}^{n}\left(\begin{array}{c}n\\k\\\end{array}\right)x^ka^{n-k}
%\end{equation}
%
%\begin{equation}
%f(x) = a_0 + \sum_{n=1}^{\infty}\left(a_n \cos\frac{n\pi x}{L} + b_n\sin\frac{n\pi x}{L}\right)
%\end{equation}



\chapter{Detalii de implementare}

Acest capitol conține câteva observații asupra procesului de dezvoltare și implementare a aplicației aferente proiectului.

Implementarea a fost realizată folosind limbajul \textbf{C++} și biblioteca \textbf{OpenGL}, în mediul de programare \textit{Microsoft \textbf{Visual Studio} Community Edition 2017}, iar testarea s-a făcut pe laptop-ul personal (\textit{Intel i5} 2.5GHz, 8GB RAM, \textit{Intel HD Graphics 4600}).

Dezvoltarea a pornit de la framework-ul descris în capitolul precedent. Acesta oferă clasa abstractă \textit{SimpleScene}, care poate fi moștenită și care oferă interfețe pentru rularea aplicației (metodele \textit{Init()}, \textit{FrameStart()}, \textit{Update()}, \textit{FrameEnd()}), randarea de mesh-uri și pentru tratarea de input de la mouse și tastatură. Aplicațiile demo sunt pur și simplu implementări ale acestei \textit{SimpleScene}. În plus, framework-ul oferă și implementarea unei camere first-person, care poate fi controlată din mouse și tastatură, pentru vizualizarea scenei.

Biblioteca utilizată pentru tipuri și funcții matematice și geometrice este \textbf{GLM}\cite{glm}.

\section{Reprezentarea corpurilor solide}

Primul obiectiv atins a fost \textbf{implementarea clasei RigidBody}[\autoref{fig:RigidBody}] și, implicit, a operației de integrare. Testarea s-a făcut cu un simplu cub asupra căruia acționează gravitația și asupra căruia se pot aplica forțe, momente și impulsuri cu ajutorul tastaturii. O mențiune specială este că am ales să stochez orientarea corpului într-un \textbf{quaternion}, în loc de o reprezentare matriceală sau cu \textit{unghiurile lui Euler}. Motivul este foarte simplu, ocupă mai puțin spațiu în memorie, nu prezintă problema \textit{Gimbal Lock}\cite{quaternions}, iar suportul \textit{GLM} pentru operații cu quaternioni este foarte bun. Exemplu de utilizare:
\begin{lstlisting}[style=myC++, label = {code:quaternion_example}, caption={actualizarea orientării în pasul de integrare}, float, floatplacement = H]
	glm::quat orientation;
	...
	orientation = orientation + deltaTime * 0.5f * glm::quat(0.0f, angVelocity) * orientation;
	orientation = glm::normalize(orientation);
\end{lstlisting}


\section {Detecția coliziunilor}
A doua etapă de dezvoltare a constat în implementarea sistemului de \textbf{detecție a coliziunilor}. Complexitatea etapei a fost semnificativ mai mare, și am întâmpinat mai multe dificultăți.

\subsection {Etapa preliminară}

Pentru \textbf{faza preliminară}, am implementat direct collider-ele de tip \textit{OBB}, cu un detector $O(n^2)$. După ce am citit despre teorema axei separatoare și eșuarea în a corecta erorile din implementarea mea a testului de intersecție, am ales să folosesc implementarea optimă propusă de Christer Ericson\cite{ericson_obb}. Tot aici, am fost nevoit să implementez abstractizarea obiectelor din scenă, care să încapsuleze obiectele \textit{RigidBody} și \textit{Collider}.

\subsection {Etapa exactă}

Faza de \textbf{detecție exactă} și generare a punctelor de coliziune este cea care mi s-a părut cea mai dificilă. A necesitat o foarte mare atenție la detalii cum ar fi ordinea vârfurilor care compun simplex-ul din algoritmul \textit{GJK} sau triunghiurile care compun poliedrul din cadrul \textit{EPA}.

\subsubsection{GJK}

Pentru \textbf{implementarea GJK}, foarte utilă mi s-a părut explicația lui Casey Muratori\cite{gjk_muratori}, care a oferit o interpretare mult mai ușor de înțeles a algoritmului decât enunțarea lui inițială\cite{gjk_original}. Remarcabil mi se pare că în cazul unui simplex tetraedru, am obținut până la 4 teste condiționale imbricate, pentru determinarea precisă a noului simplex și a noii direcții. Includ aici cazul muchie, deoarece mi se pare că algoritmul în pseudocod nu spune prea multe cititorilor nefamiliarizați cu acesta.

\begin{lstlisting}[style=myC++, label={code:gjk_simplex2}, caption = {cazul muchie în algoritmul GJK}]
void GJKEPA::GJKEPACollisionPointGenerator::doSimplex2()
{
	/* simplex is an edge \vec{AB}, A was just added */
	glm::vec3 vecAO = -simplex.a.v;
	glm::vec3 vecAB = simplex.b.v - simplex.a.v;
	/* origin is in the direction of \vec{AB}
	search direction is perpendicular to \vec{AB} and coplanar with \vec{AO} */
	if (glm::dot(vecAB, vecAO) > 0) {
		searchDir = glm::normalize(glm::cross(glm::cross(vecAB, vecAO), vecAB));
	}
	else {
		simplex.set(simplex.a);
		searchDir = glm::normalize(vecAO);
	}
}
\end{lstlisting}

Ofer și codul pentru tratarea cazului triunghi în \autoref{code:gjk_simplex3}.
\subsubsection{EPA}

Un alt impediment a fost reprezentat de \textbf{implementarea EPA}. Problemele întâlnite au fost:
\begin{itemize}
	\item felul în care ar trebui stocat poliedrul -- am ales să îl rețin ca o listă de triunghiuri
	\item pasul de expansiune a poliedrului -- adăugarea unui nou vârf presupune eliminarea  triunghiurilor care ar fi acoperite de acesta
	\begin{itemize}
		\item parcurg muchiile triunghiurilor care ar fi acoperite în sens trigonometric
		\item construiesc o listă cu aceste muchii
		\item în momentul în care am ajuns la o muchie deja existentă în listă, o elimin cu totul, întrucât aceasta ar fi între două triunghiuri care trebuie eliminate
		\item la final, în lista de muchii, rămân doar muchiile de frontieră
		\item cu fiecare din aceste muchii și noul punct, formez noi triunghiuri care vor fi adăugate la poliedru
	\end{itemize}
\end{itemize}

\begin{figure}[H]
	\centering
	\begin{subfigure}[h]{0.32\textwidth}
		\includegraphics[width=\textwidth]{pics/EPA0.png}
		\label{fig:EPA0}
		\caption{punctul roșu este noul punct, iar săgețile colorate determină sensul de parcurgere a triunghiurilor}
		\vfill
	\end{subfigure}
	\hfill
	\begin{subfigure}[h]{0.32\textwidth}
		\includegraphics[width=\textwidth]{pics/EPA1.png}
		\label{fig:EPA1}
		\caption{poliedrul după eliminarea celor două triunghiuri care ar fi acoperite de noul punct}
		\vfill
	\end{subfigure}
 	\hfill
 	\begin{subfigure}[h]{0.32\textwidth}
 		\includegraphics[width=\textwidth]{pics/EPA2.png}
 		\label{fig:EPA2}
 		\caption{poliedrul după construirea noilor triunghiuri}
 		\vfill
	\end{subfigure}
	\caption{Un pas de extindere al poliedrului în cadrul EPA}
\end{figure}

Secvența de cod care face exact acest lucru este:
\begin{lstlisting}[style=myC++, label={code:epa_expansion_step}, caption = {extinderea politopului în cadrul EPA}]
/* adds an edge to the list of edges or removes it, if it is already there, but reversed */
static void addRemoveEdge(std::list<GJKEPA::Edge> &edges, const GJKEPA::MinkowskiDiffPt &a, const GJKEPA::MinkowskiDiffPt &b) {
	for (auto it = edges.begin(); it != edges.end(); it++) {
		if (it->a.v == b.v && it->b.v == a.v) {
			/* found reversed edge, just remove it */
			it = edges.erase(it);
			return;	}}
	edges.push_back(GJKEPA::Edge(a, b));
}
[...]
for (auto it = triangles.begin(); it != triangles.end();) {
	if (glm::dot(it->vecABC, nextSup.v - it->a.v) > -EPA_EPSILON) {
		/* update the edge list in order to remove the triangles facing this point */
		addRemoveEdge(edges, it->a, it->c);
		addRemoveEdge(edges, it->c, it->b);
		addRemoveEdge(edges, it->b, it->a);
		it = triangles.erase(it);
		continue; }
	it++; }
/* re-create the triangles from the remaining edges */
for (Edge e : edges) {
	triangles.push_back(Triangle(nextSup, e.a, e.b));
}
\end{lstlisting}

\section{Rezolvarea coliziunilor}

\textbf{Rezolvarea coliziunilor} este componenta cea mai complexă a simulatorului din punct de vedere matematic și programatic. Procesul a fost descris mai pe larg în capitolele precedente, dar reiterez faptul că am ales o metodă de rezolvare a interpenetrării bazată pe \hyperref[pseudo_velocities]{metoda pseudo-vitezelor}. În plus, informațiile de coliziune sunt încapsulate în structuri numite \textit{contacte}, care pot supraviețui de la un cadru la altul și sunt grupate în manifold-uri diferite pentru fiecare pereche de obiecte aflate în coliziune.  Astfel, rezolvarea unui manifold de contact se realizează în felul următor:

Sunt calculate pozițiile relative, coeficienții de frecare și elasticitate, viteza corpurilor dorită după rezolvare.
\begin{lstlisting}[style=myC++, label={code:solveManifold_a}]
void SequentialImpulseContactResolver::solveContactManifold(ContactManifold &manifold, float deltaTime)
{
	unsigned int penetrationIterations = 0;
	unsigned int velocityIterations = 0;

	for (auto & contact : manifold.contacts) {
		for (uint8_t i = 0; i < 2; i++) {
			if (contact->objects[i]->collider->body != nullptr)
				contact->objects[i]->collider->body->isAwake = true;
		}

		contact->computeDerivedData(deltaTime);
		contact->desiredDeltaVelocity = computeDesiredDeltaVelocity(contact);
	}
[cont.]
\end{lstlisting}

Rezolvarea interpenetrării presupune modificarea poziției corpurilor astfel încât acestea să nu se mai intersecteze. Pentru a obține rezultate mai realiste, se aplică atât o mișcare liniară, cât și una unghiulară. Calculul acestora presupune determinarea inerției liniare și unghiulare pentru ambele corpuri, împărțirea acestora la inerția totală necesară mișcării unitare și înmulțirea cu distanța de penetrare, pentru a obține cantitățile de mișcare necesare pentru separare.
\begin{lstlisting}[style=myC++, label={code:solveManifold_b}]
[cont.]
	/* fix interpenetration */
	for (penetrationIterations = 0; penetrationIterations < PhysicsSettings::get().collisionResolution.penMaxIterations; penetrationIterations++) {
		/* get the contact with deepest penetration */
		Contact *deepestContact = manifold.getDeepestContact();

		if (deepestContact == nullptr || deepestContact->penetration < PhysicsSettings::get().epsilons.penEpsilon) {
			penetrationIterations++;
			break;
		}

		/* compute and apply position update */
		applyPositionUpdate(manifold, deepestContact);
	}
[cont.]
\end{lstlisting}

Se rezolvă vitezele corpurilor prin metoda impulsurilor secvențiale. Calculul impulsului care să stabilească viteza corectă de după coliziune se bazează din nou, pe componentele individuale -- cea liniară și cea unghiulară.
\begin{lstlisting}[style=myC++, label={code:solveManifold_c}]
[cont.]
	/* fix velocities */
	for (velocityIterations = 0; velocityIterations < PhysicsSettings::get().collisionResolution.velMaxIterations; velocityIterations++) {
		/* get the contact with the lowest desired delta velocity (aka the fastest one) */
		Contact *fastestContact = manifold.getFastestContact();

		if (fastestContact == nullptr || fastestContact->desiredDeltaVelocity >= PhysicsSettings::get().epsilons.velEpsilon) {
			velocityIterations++;
			break;
		}

		/* compute and apply velocity update */
		applyVelocityUpdate(manifold, fastestContact);
	}
}
\end{lstlisting}

Deoarece rezolvarea pe rând a contactelor dintr-un manifold poate duce la situații în care un alt contact decât cel curent să fie accentuat, folosesc mai multe iterații pentru aplicarea celor doi pași de mai sus, de fiecare dată încercând să rezolv cel mai adânc, respectiv cel mai rapid contact din manifold, astfel încât soluția să poată converge. Odată rezolvat un contact, schimbările aduse de acesta sunt aplicate tuturor celorlalte contacte din manifold.

Principala resursă folosită pentru înțelegerea acestui proces a fost cartea\cite{millington} lui Ian Millington, iar soluția mea urmează îndeaproape indicațiile și implementarea acestuia.

\section {Controlul obiectelor}
Controlul obiectelor din scenă este realizat cu ajutorul unui obiect\textbf{ ObjectSpawner}[\autoref{fig:ObjectSpawner}], care menține o listă cu toate obiectele și care se ocupă de instanțierea și de actualizarea lor. Folosirea acestui obiect care să abstractizeze operațiile de bază (instanțiere, actualizare, încărcare/salvare scene) asigură un cod cât mai lizibil în aplicația principală și posibilitatea de a folosi aceste apeluri chiar și în cadrul interfeței grafice. Pentru simplitate, poziția acestuia este determinată pe baza poziției camerei și un deplasament față de aceasta. Exemple de folosire:

\begin{lstlisting}[style=myC++]
ObjectSpawner *spawner = new ObjectSpawner();
[...]
// instantiaza un nou obiect la runtime, cu parametri aleatori(sau nu), stabiliti de spawner
spawner->spawnNewObject();
// instantiaza un nou perete cu parametri alesi de utilizator                             
spawner->spawnWallStatic(position, scale, orientation);
// incarca o noua scena din fisier
spawner->loadFromFile("test.json");
// elimina obiectele prea indepartate si apeleaza update() pentru fiecare obiect
spawner->updateObjects();
\end{lstlisting}

\section {Interfața grafică}
Folosirea \textbf{Dear ImGui} nu a ridicat nicio problemă majoră. A trebuit să redirectez evenimentele de tastatură și scroll către cele definite în exemplul oficial de folosire a bibliotecii cu \textit{GLFW}, dar integrarea a fost facilă în rest. Definirea UI-ului am realizat-o într-un fișier separat, iar funcția pentru desenarea acestuia este apelată la sfârșitul fiecărui cadru. Am preluat în plus un addon pentru interfațarea cu sistemul de fișiere la alegerea unui fișier din care să se încarce o nouă scenă și să îmi definesc un nou widget pentru afișarea personalizată a celor 3 câmpuri dintr-un \textit{vec3}. Fiind vorba de un GUI imediat, elementele de logică sunt strâns legate de cele ce țin de desenare. Exemplu din \textit{ui.cpp}:

\begin{lstlisting}[style=myC++, label={code:imguiExample}, caption = {widget-urile pentru stabilirea parametrilor impliciti ai corpurilor solide}]
PhysicsSettings *settings = PhysicsSettings::get()
[...]
if (ImGui::TreeNode("rigid bodies default values"))
{
	ImGui::PushItemWidth(128);
	ImGui::DragFloat("mass", &settings->rigidBodies.defaultMass, 1.0f, 0.0f, 10000.0f, "%.1f");

	ImGui::DragFloat("friction coefficient", &settings->rigidBodies.defaultFrictionCoef, 0.005f, 0.0f, 1.0f);
	ImGui::DragFloat("restitution coefficient", &settings->rigidBodies.defaultRestitutionCoef, 0.005f, 0.0f, 1.0f);

	ImGui::PopItemWidth();
	ImGui::TreePop();
}
\end{lstlisting}

\section {Parametrii simulării}

Pentru a nu hardcoda valori literale direct în cod, pentru a avea acces facil la ele, și pentru a le putea modifica la runtime, toate setările aplicației -- parametri de simulare, constante, erori admisibile, parametri impliciți pentru obiecte, configurația spawner-ului sau elementele desenate -- sunt reținute într-un obiect \textbf{PhysicsSettings}, care este un singleton accesibil de oriunde este nevoie în aplicație. Cea mai mare parte dintre acestea pot fi definite și în cadrul scenelor încărcabile în format \textit{.json}.

\begin{lstlisting}[language=json, label={code:json_example}, caption={Exemplu de scenă în format .json}]
{
	"settings" : {
		"gravity" : {
			"x" : 0.0,
			"y" : -20.0,
			"z" : 0.0
		},
		"timeScale" : 1.0,
		"rendering" : {
			"renderColliders" : false
		}
	},
	"objects" : [
		{
			"type" : "box",
			"name" : "cube0",
			"position" : {
				"x" : 12.6,
				"y" : 4.0,
				"z" : 0.0
			},
			"frictionCoef" : 0.6,
			"restitutionCoef" : 0.1,
			"mass" : -1.0
		}
	]
}
\end{lstlisting}
Un exemplu mai complet poate fi găsit în [\autoref{code:json_full}].
%
%În plus fata de capitolul precedent acesta conține elemente specifice ale rezolvării problemei care au presupus dificultăți deosebite din punct de vedere tehnic. Pot fi incluse configurații, secvențe de cod, pseudo-cod, implementări ale unor algoritmi, analize ale unor date, scripturi de testare. De asemenea, poate fi detaliat modul în care au fost utilizate tehnologiile introduse in capitolul 3.
%
%
%Criterii pentru calificativul \textit{Ne\textit{Satisfăcător}}: 
%\begin{itemize}
%	\item	Sunt prezentate pe scurt scheme și pseudo-cod.
%\end{itemize}
%Criterii pentru calificativul \textit{Satisfăcător}: 
%\begin{itemize}
%	\item	Descriere sumara a implementării, prezentarea unor secvențe nerelevante de cod, scheme, etc. 
%\end{itemize}
%Criterii pentru calificativul \textit{Bine}: 
%\begin{itemize}
%	\item	Descrierea detaliată a algoritmilor/structurilor utilizați; Prezentarea etapizată a dezvoltării, inclusiv cu dificultăți de implementare întâmpinate, soluții descoperite; (dacă este cazul) demonstrarea corectitudinii algoritmilor utilizați. 
%\end{itemize}
%
%\section{Indicații formatare tabele}
%Se recomandă utilizarea tabelelor de forma celui de mai jos.  Font size :  9. 
%Orice tabel prezent în teză va fi referit în text; exemplu: a se vedea Tabel~\ref{tab:criterii}.
%
%\begin{table}[th]\small\linespread{1}
%\caption{Sumarizare criterii}
%\label{tab:criterii}
%\begin{tabular}{l >{\raggedright\arraybackslash}p{8cm} >{\raggedright\arraybackslash}p{4cm}}
%\textbf{Calificativ} & \textbf{Criteriu} & \textbf{Observații} \\\hline
%\textbf{Nesatisfacator} & Sunt prezentate pe scurt scheme și pseudo-cod & \\\hline
%\textbf{Satisfacator} &Descriere sumara a implementării, prezentarea unor secvențe nerelevante de cod, scheme, etc.& \\
%\hline
%\textbf{\textit{Bine}} &Descrierea detaliată a algoritmilor/structurilor utilizați; Prezentarea etapizată a dezvoltării, inclusiv cu dificultăți de implementare întâmpinate, soluții descoperite; (dacă este cazul) demonstrarea corectitudinii algoritmilor utilizați. & Pot fi incluse configurații, secvente de cod, pseudo-cod, implementări ale unor algoritmi, analize ale unor date, scripturi de testare. \\
%\hline
%\end{tabular}
%\end{table}


\chapter{Evaluare}
%Acest capitol trebuie să răspundă, în principiu, la 2 întrebări și să se încheie cu o discuție a rezultatelor obținute. Cele doua întrebări la care trebuie sa se răspundă sunt:
%\begin{enumerate}
%	\item  \textbf{Merge corect?} (Conform specificațiilor extrase în capitolul 2); 
%Evaluarea dacă merge corect se face pe baza cerințelor identificate în capitolele anterioare. 
%
%	\item Cât de \textit{Bine} merge / cum se compară cu soluțiile existente? (pe baza unor metrici clare). 
%Evaluarea cât de \textit{Bine} merge trebuie să fie bazată pe procente, timpi, cantitate, numere, \textbf{comparativ cu soluțiile prezentate în capitolul 3}. Poate fi vorba de performanță, overhead, resurse consumate, scalabilitate etc. 
%\end{enumerate}
%
%În realizarea discuției, se vor utiliza tabele cu procente, rezultate numerice și grafice. În mod obișnuit, aici se fac comparații și teste comparative cu alte proiecte similare (dacă există) și se extrag puncte tari și puncte slabe. Se ține cont de avantajele menționate și se demonstrează viabilitatea abordării / aplicației, de dorit prin comparație cu alte abordări (dacă acest lucru este posibil). Cuvântul cheie la evaluare este ``metrică'': trebuie să aveți noțiuni măsurabile și cuantificabile. În cadrul procesului de evaluare, explicați datele, tabelele și graficele pe care le prezentați și insistați pe relevanța lor, în următorul stil: ``este de preferat ... deoarece …''; explicați cititorului nu doar datele ci și semnificația lor și cum sunt acestea interpretate. Din această interpretare trebuie să rezulte poziționarea proiectului vostru printre alternativele existente, precum și cum poate fi acesta îmbunătățit în continuare.
%
%Criterii pentru calificativul \textit{Ne\textit{Satisfăcător}}: 
%\begin{itemize}
%	\item Aplicația este testată dar rulează pe calculatorul studentului, nu există posibilități de testare, nu a fost validată cu clienți / utilizatori;
%	\item Nu au fost realizate comparații cu alte sisteme similare.
%\end{itemize}
%
%Criterii pentru calificativul \textit{Satisfăcător}: 
%\begin{itemize}
%	\item \dezvoltare  Există teste unitare și de integrare, există o strategie de punere în funcțiune (deployment), există validare minimală cu clienții / utilizatorii.
%	\item \cercetare Principalele componente și soluția în ansamblu au fost evaluate din punct de vedere al performanței, însă nu sunt folosite seturi de date standard, există unele erori de interpretare a datelor.
%	\item \ambele Discuție minimală asupra relevanței rezultatelor prezentate, comparație minimală cu alte sisteme similare.
%\end{itemize}
%
%Criterii pentru calificativul \textit{Bine}: 
%\begin{itemize}
%	\item \dezvoltare Teste unitare și de integrare, instrumente de punere in funcțiune (deployment) utilizate și care arată lucru constant de-a lungul semestrului, lucrare validată cu clienții / utilizatorii, produs în producție.
%	\item \cercetare Componentele și soluția în ansamblu au fost evaluate din punct de vedere al performanței, folosind seturi de date standard și cu o interpretare corectă a rezultatelor.
%	\item \ambele Discuție cu prezentarea calitativă și cantitativă a rezultatelor, precum și a relevanței acestor rezultate printr-o comparație complexă cu alte sisteme similare.
%\end{itemize}
Pentru evaluarea aplicației obținute, voi încerca să fac o analiză din perspectiva \textbf{obiectivelor propuse} inițial, dar și din punct de vedere al \textbf{performanței} acesteia.

\section{Atingerea obiectivelor}

La sfârșitul dezvoltării aplicației, am reușit cu succes să ating toate obiectivele pe care mi le-am propus. Am obținut un sistem pentru simularea interacțiunilor mecanice (ciocniri) între corpuri solide într-un spațiu 3D. Răspunsul la aceste interacțiuni este credibil pentru utilizatorul obișnuit, iar interfața pusă la dispoziție permite un control fin asupra scenei.

Includ o listă completă de facilități oferite și suportate, care să evidențieze cele spuse mai sus:
\begin{itemize}
	\item reprezentarea corpurilor 3D în scenă se realizează cu ajutorul obiectelor de tip RigidBody[\autoref{fig:RigidBody}], în care:
		\begin{itemize}
			\item masa, factorii de scalare, coeficienții de frecare/elasticitate sunt mărimi constante
			\item forțele și momentele forței care acționează asupra corpurilor sunt mărimi brute care sunt folosite la ajustarea mărimilor secundare
			\item vitezele și accelerațiile liniare și unghiulare sunt mărimi secundare, care sunt utilizate la actualizarea mărimilor finale
			\item poziția și orientarea sunt mărimi finale, care determină starea absolută a corpurilor într-un moment de timp $t$
		\end{itemize}
	\item corpurile au atribuite forme elementare și volume încadratoare, astfel încât să se poată detecta coliziunile dintre acestea în două etape:
		\begin{itemize}
			\item în etapa preliminară, se realizează teste de intersecție mai puțin precise, pe baza volumelor încadratoare
			\item în etapa exactă, se identifică toate coliziunile reale și sunt determinate informațiile care să ajute la rezolvarea acestora
		\end{itemize}
	\item toate coliziunile identificate sunt soluționate printr-un răspuns aplicat corpurilor implicate, care are rolul de a:
		\begin{itemize}
			\item asigura un set de viteze liniare și unghiulare post-coliziune realiste, care să respecte, pe cât posibil, legile fizicii
			\item separa corpurile imediat, în cazul întrepătrunderilor vizibile
		\end{itemize}
	\item toate obiectele și alte elemente anexe(puncte de coliziune, normale, volume încadratoare etc.) sunt desenate pe ecran, într-o fereastră OpenGL
	\item este oferită o interfață cu utilizatorul care să îi permită acestuia să:
		\begin{itemize} 
			\item încarce sau să salveze scene în format .json [\autoref{fig:gui_load_scene}]
			\item instanțieze noi obiecte
			\item controleze un obiect individual selectat de acesta(atât starea, cât și parametrii constanți) [\autoref{fig:gui_object_control}]
			\item altereze setările simulării [\autoref{fig:gui_simulation_settings}]
			\item poată naviga în scenă
			\item aleagă exact ce elemente dorește să fie desenate [\autoref{fig:gui_rendering}]
		\end{itemize}
	\item corpuri 3D suportate: cub, paralelipiped dreptunghic, sferă, cilindru, capsulă și variații obținute prin scalare ale acestora
	\item sisteme de operare suportate: Windows
	\item biblioteci adiționale: doar cele incluse în folder-ul /libs
\end{itemize}

\begin{figure}[H]
	\centering
	\makebox[\textwidth][c]{\includegraphics[width=1.2\linewidth]{pics/screenshot0.png}}
	\caption[]{Interfața grafică oferită}
	\label{fig:gui_showcase}
\end{figure}

\section{Evaluare performanțe}
Pentru evaluarea performanțelor aplicației, propun 3 scenarii de test diferite. Parametrii simulării și cei impliciți ai corpurilor sunt cei din [\autoref{code:json_full}], dacă nu este specificat altfel.
Toate testele au fost efectuate pe laptop-ul personal (\textit{Intel i5} 2.5GHz, 8GB RAM, \textit{Intel HD Graphics 4600}), utilizând mediul de dezvoltare \textit{Visual Studio Community Edition 2017}.

\subsection{Stive de obiecte}
Pentru acest test, am considerat un număr variabil de cuburi unitare stivuite unul peste celălalt deasupra unui perete static care ține loc de podea și am măsurat timpul până când oricare două cuburi alăturate nu mai sunt în contact.

\begin{table}[th]\small\linespread{1}
	\centering
	\begin{tabular}{| l | >{\raggedright\arraybackslash}p{3cm} | >{\raggedright\arraybackslash}p{8cm} |}
		\hline
		\textbf{Nr. cuburi} & \textbf{Timp până la separare (secunde)} & \textbf{Observații} \\\hline
		1 & $\infty$ & cubul este complet stabil \\\hline
		2 & 40 & vibrații foarte mici, dar ansamblul este stabil \\\hline
		3 & 30 & vibrații foarte mici, dar ansamblul este stabil \\\hline
		4 & 30 & vibrații foarte mici, dar ansamblul este stabil \\\hline
		5 & 25 & cuburile alunecă în mod vizibil \\\hline
		6 & 15 & vibrații observabile, cuburile alunecă în mod vizibil \\\hline
		7 & 12 & vibrații observabile, cuburile alunecă în mod vizibil \\\hline
		8 & 8  & vibrații observabile, cuburile alunecă în mod vizibil \\\hline
		16 & 4 & stiva este complet instabilă \\\hline	
	\end{tabular}
	\caption{Testul pentru stive de obiecte}
	\label{tab:stacking}
\end{table}

Creșterea pragului de mișcare pentru trecerea obiectelor în starea de sleep poate duce la stabilizarea stivelor de 2, 3, sau 4 obiecte. Pentru uz general, consider rezultatele obținute mulțumitoare.

\subsection {Număr de obiecte în scenă}
Pentru acest test, am considerat un număr variabil de cuburi instanțiate deasupra solului și lăsate să cadă. Cuburile sunt instanțiate astfel încât acestea să se afle în contact sau nu. La impactul cu solul, se va aplica un răspuns pentru coliziune. Am măsurat numărul de cadre efectuate pe secundă.

\begin{table}[th]\small\linespread{1}
	\centering
	\begin{tabular}{| l | >{\raggedright\arraybackslash}p{3cm} | >{\raggedright\arraybackslash}p{3cm} | >{\raggedright\arraybackslash}p{6cm} |}
		\hline
		\textbf{Nr. cuburi} & \textbf{Nr. cadre pe secundă (în cădere)} & \textbf{Nr. cadre pe secundă (la sol)} & \textbf{Observații} \\\hline
		1   & 60.0 & 59.9 & funcționare fluidă \\\hline
		2   & 60.0 & 59.9 & funcționare fluidă \\\hline
		4   & 60.0 & 59.8 & funcționare fluidă \\\hline
		8   & 59.9 & 59.6 & funcționare fluidă \\\hline
		16  & 59.6 & 58.9 & funcționare fluidă \\\hline
		32  & 59.2 & 57.7 & funcționare acceptabilă \\\hline
		64  & 50.0 & 30.4 & o cădere mare, dar simularea este încă stabilă \\\hline
		128 & 18.5 & 12.3 & simularea este instabilă \\\hline
		256 & 6.3  & 0.0  & simularea este complet instabilă \\\hline	
	\end{tabular}
	\caption{Testul pentru număr de obiecte în scenă}
	\label{tab:fps_num_objects}
\end{table}

Așa cum era de așteptat, simularea devine instabilă când în scenă se află un număr mare de obiecte. În plus, rezolvarea coliziunilor are o influență semnificativă asupra vitezei aplicației.

Pentru a doua parte a acestui test, am determinat timpul petrecut de aplicație în fiecare dintre subsistemele majore ale acesteia pentru o scenă cu 32 de cuburi aflate în contact cu solul.

\begin{table}[th]\small\linespread{1}
	\centering
	\begin{tabular}{| l | >{\raggedright\arraybackslash}p{3cm} |}
		\hline
		\textbf{Etapa} & \textbf{timp (ms)} \\\hline
		desenare obiecte   & 4.06  \\\hline
		integrare & 0.22 \\\hline
		detecție posibile coliziuni & 1.33 \\\hline
		stabilire puncte de contact & 3.54 \\\hline
		rezolvare contacte & 0.76 \\\hline
		desenare UI  &  2.66 \\\hline
		\end{tabular}
	\caption{Timpul petrecut în fiecare dintre subsistemele simulatorului într-un cadru}
	\label{tab:time_elapsed}
\end{table}

Rezultatele nu sunt extrem de surprinzătoare. Etapa cea mai costisitoare, excluzând pe cele de desenare, este generarea punctelor de contact. Complexitatea algoritmilor folosiți este potrivită doar pentru teste de dimensiuni mici. Pentru măsurare am folosit profiler-ul oferit de \textit{Visual Studio 2017}, care oferă detalii exacte asupra căror apeluri de funcții au ocupat cei mai mulți cicli de procesor.


\subsection{Plan înclinat}

Acest test nu are fundamente obiective, dar verifică funcționarea corectă a frecării în cadrul rezolvării contactelor. Toate tipurile de obiecte sunt instanțiate deasupra unui perete care joacă rolul unui plan înclinat de $30\deg$. Sunt considerate 3 situații: coeficientul de frecare atât al corpurilor, cât și al planului înclinat ia pe rând fiecare dintre valorile $0.0$, $0.5$, respectiv $1.0$.

În cazul sferei, ar trebui să se poată observa cu ușurință ca aceasta nu se rotește deloc în cazul fără frecare și se va roti puțin sau mai mult în celelalte două cazuri. Pentru vizualizare, folosesc \textit{OBB}-ul asociat sferei, iar ca metrică, rețin norma maximă a vitezei unghiulare atinsă de sferă.

\begin{table}[th]\small\linespread{1}
	\centering
	\begin{tabular}{| l | >{\raggedright\arraybackslash}p{3cm} |}
		\hline
		\textbf{Coeficient de frecare} & \textbf{Viteza unghiulară maximă atinsă} \\\hline
		0.0   & 0.02  \\\hline
		0.5   & 1.04 \\\hline
		1.0   & 1.32 \\\hline
	\end{tabular}
	\caption{Testul pentru verificarea tratării corecte a frecărilor}
	\label{tab:friction_test}
\end{table}

Se observă diferența clară între cazul fără frecare și celelalte două. Pentru o vizualizare și mai bună, pot fi încărcate scenele din /demos/slope/.

\subsection {Utilizare resurse}

Câteva detalii despre resursele utilizate de aplicație:
\begin{itemize}
	\item aplicația rulează pe un singur thread
	\item \textit{Visual Studio} raportează o amprentă în memorie de 45.5 MB; cea mai mare parte este ocupată de biblioteci și alocări realizate de backend
	\item dimensiunea heap-ului se menține în jurul valorii de ~5900 KB (de exemplu, încărcarea unei scene cu 32 de obiecte va produce 265 de alocări totalizând 34.80 KB)
\end{itemize}


Per total, aplicația nu a atins nivelul de performanță pe care mi l-aș fi dorit, optimizările cele mai esențiale care ar trebui efectuate fiind cele ce țin de alocarea și dealocarea inteligentă a memoriei la runtime, dar și optimizări ale algoritmilor folosiți în cadrul simulatorului.

\chapter{Concluzii}

În urma realizării acestui proiect, am atins toate obiectivele pe care mi le-am propus, ceea ce mă face să îl consider un succes.

Pe plan teoretic, am reușit să aprofundez suficient de multe cunoștințe astfel încât pe viitor să pot extinde și îmbunătăți aplicația obținută sau să contribui la alte proiecte asemănătoare. Am dobândit o înțelegere foarte bună a arhitecturii unui motor de fizică și a câtorva dintre algoritmii și metodele folosite des în industrie.  Mi-am exersat abilitățile de a programa în C++, mi-am reîmprospătat cunoștințele de \textit{OpenGL} și m-am familiarizat cu biblioteci noi care mi-ar putea fi utile și în viitor.

Practic, am obținut o aplicație grafică \textit{OpenGL}, capabilă să ruleze o simulare de dimensiune rezonabilă (max. 64 de obiecte) a interacțiunilor mecanice dintre corpuri 3D pe sistemul de operare Windows. În plus, am implementat cu succes o interfață grafică pentru utilizator, prin care acesta poate încărca sau salva scene, controla parametrii simulării și direct obiectele din scenă.

În realizarea aplicației:
	\begin{itemize}
		\item am implementat o reprezentare a corpurilor solide robustă și minimală
		\item am implementat o serie de corpuri 3D (cub, paralelipiped dreptunghic, sferă, cilindru, capsulă) care să aibă asociate câte un obiect \textit{RigidBody} și care să participe în simulare
		\item am implementat un integrator numeric bazat pe metoda Euler implicită
		\item am implementat un sistem de detecție preliminară a coliziunilor, cu ajutorul volumelor încadratoare de tip \textit{OBB}
		\item am implementat algoritmii \textit{GJK} și \textit{EPA} pentru detecția și calculul punctelor de coliziune
		\item am implementat un rezolvitor de coliziuni bazat pe metoda impulsurilor secvențiale
		\item am folosit \textit{Dear ImGui} pentru realizarea interfeței grafice
		\item am testat și am oferit spre folosire o serie de demo-uri care să ilustreze capabilitățile simulatorului
	\end{itemize}

Limitările aplicației sunt:
\begin{itemize}
	\item numărul mic de forme care pot fi simulate -- nu există posibilitatea de a încărca mesh-uri poligonale complexe
	\item performanța mai puțin decât ideală
	\item realismul simulării este mulțumitor, dar nu excelent
	\item lipsa suportului pentru alte tipuri de constrângeri mecanice (cum ar fi articulațiile)
\end{itemize}
Acestea sunt dictate de:
	\begin{itemize}
		\item erori numerice, datorate lucrului cu numere în virgulă mobilă
		\item utilizarea unor parametri neoptimi în cadrul simulării
		\item bug-uri și calitatea implementării
		\item folosirea unui algoritm ineficient pentru detecția preliminară a coliziunilor
		\item utilizarea ineficientă a memoriei
	\end{itemize}

Acestea fiind spuse, mențin posibilitatea ca pe viitor să continui lucrul la aplicație. Cele mai importante adăugiri pe care le-aș putea face sunt:
\begin{itemize}
	\item implementarea unei ierarhii de de volume încadratoare pentru a reduce complexitatea algoritmului $O(n^2)$ folosit în prezent în faza preliminară a detecției de coliziuni
	\item alternativ, implementarea unui arbore al scenei de tip \textit{BSP} sau octree
	\item oferirea unui suport pentru încărcarea de mesh-uri convexe și adaptarea algoritmilor deja implementați la acest caz general
	\item implementarea și altor volume încadratoare pentru a putea compara performanțele acestora
	\item rafinarea parametrilor simulării
	\item implementarea și altor algoritmi, cum ar fi metoda contactelor simultane
	\item optimizarea lucrului cu heap-ul, prin implementarea unui alocator propriu 
	\item repararea bug-urilor existente
\end{itemize}
%În acest capitol este sumarizat întreg proiectul, de la obiective, la implementare, si la relevanta rezultatelor obținute. În finalul capitolului poate exista o subsecțiune de ``Dezvoltări ulterioare''.
%
%Criterii pentru calificativul \textit{Ne\textit{Satisfăcător}}: 
%\begin{itemize}
%	\item	Concluziile nu sunt corelate cu conținutul lucrării;
%\end{itemize}
%
%Criterii pentru calificativul \textit{Satisfăcător}: 
%\begin{itemize}
%	\item	Concluziile sunt corelate cu conținutul lucrării, însă nu se oferă o imagine asupra calității și relevantei rezultatelor obținute;
%\end{itemize}
%
%Criterii pentru calificativul \textit{Bine}: 
%\begin{itemize}
%	\item	Concluziile sunt corelate cu conținutul lucrării, și se oferă o imagine precisa asupra relevantei și calității rezultatelor obținute în cadrul proiectului. 
%\end{itemize}



% * <marios.choudary@gmail.com> 2018-02-28T12:07:48.730Z:
% 
% > BIBLIOGRAFIE
% Am adaugat un paragraf cu cateva detalii despre folosirea citarilor bibliografice in Latex, despre folosirea lui "\cite" si despre posibilitatea folosirii bibliografiei si direct in fisierul Latex.
% 
% ^.

%\begin{itemize}
%	\item 	NU utilizați referințe la Wikipedia sau alte surse fără autor asumat.
%	\item 	Pentru referințe la articole relevante accesibile în web (descrise prin URL) se va nota la bibliografie și data accesării.
%	\item 	Mai multe detalii despre citarea referințelor din internet se pot regăsi la:
%	\begin{itemize}
%		\item	\url{http://www.writinghelp-central.com/apa-citation-internet.html}
%		\item	\url{http://www.webliminal.com/search/search-web13.html}
%	\end{itemize}
%	\item 	Note de subsol se utilizează dacă referiți un link mai puțin semnificativ o singură dată; Dacă nota este citată de mai multe ori, atunci utilizați o referință bibliografică.
%	\item 	Dacă o imagine este introdusă în text și nu este realizată de către autorul lucrării, trebuie citată sursa ei (ca notă de subsol sau referință - este de preferat utilizarea unei note de subsol).
%	\item 	Referințele se pun direct legate de text (de exemplu ``KVM [1] uses'', ``as stated by Popescu and Ionescu [12]'', etc.). Nu este recomandat să folosiți formulări de tipul ``[1] uses'', ``as stated in [12]'', ``as described in [11]'' etc..
%	\item 	Afirmațiile de forma ``are numerous'', ``have grown exponentially'', ``are among the most used'', ``are an important topic'' trebuie să fie acoperite cu citări, date concrete si analize comparative.
%	\begin{itemize}
%		\item	Mai ales în capitolele de introducere, ``state of the art'', ``related work'' sau ``background'' trebuie să vă argumentați afirmațiile prin citări. Fiți autocritici și gândiți-vă dacă afirmațiile au nevoie de citări, chiar și cele pe care le considerați evidente.
%		\item	Cea mai mare parte dintre citări vor fi în capitolele de introducere ``state of the art'', ``related work'' sau ``background''.
%	\end{itemize}
%	\item 	Toate intrările bibliografice trebuie citate în text. Nu le adăugați pur și simplu la final.
%	\item 	Nu copiați sau traduceți niciodată din surse de informație de orice tip (online, offline, cărți, etc.). Dacă totuși doriți să oferiți, prin excepție, un citat celebru - de maxim 1 frază- utilizați ghilimele și evident menționați sursa. .
%	\item 	Dacă reformulați idei sau creați un paragraf rezumat al unor idei folosind cuvintele voastre, precizați cu citare (referință bibliografică) sau cu notă de subsol sursa sau sursele de unde ați preluat ideile.
%\end{itemize}
%
%Trebuie respectat un singur standard de trimiteri bibliografice (citare), dintre următoarele alternative:
%\begin{itemize}
%	\item APA (\url{http://pitt.libguides.com/c.php?g=12108\&p=64730})
%	\item IEEE (\url{https://ieee-dataport.org/sites/default/files/analysis/27/IEEE\%20Citation\%20Guidelines.pdf}) 
%	\item Harvard (\url{https://libweb.anglia.ac.uk/referencing/harvard.htm})
%	\item Cu numerotarea referințelor în ordine alfabetică sau în ordinea apariției în text (de exemplu, stilul cu numere folosit de unele publicații ACM - \url{https://www.acm.org/publications/authors/reference-formatting}) 
%\end{itemize}
%
%În Latex este foarte ușor să folosiți referințe într-un mod corect și unitar, fie prin adăugarea unei secțiuni
%\verb!\begin{thebibliography}!
%(vezi la sfârșitul acestei secțiuni), fie printr-un fișier separat de tip bib, folosind comanda
%\verb!\bibliography{}!,
%așa cum procedăm mai jos prin folosirea fișierului ``bibliography.bib''. În orice caz, în Latex va trebui să folosiți comanda
%\verb!\cite{}!
%pentru a adăuga referințe, iar această comandă trebuie folosită direct în text, acolo unde vreți sa apară citația, ca în exemplele următoare:
%\begin{itemize}
%	\item Articol jurnal: ~\cite{article};
%	\item Articol conferință:~\cite{proc};
%	\item Carte: ~\cite{book};
%	\item Weblink: ~\cite{silva};
%\end{itemize}
%
%\textbf{Important}: în această secțiune de obicei apar doar intrările bibliografice (adică doar listarea referințelor). Citarea lor prin comanda cite și explicații legate de ele trebuie facute în secțiunile anterioare. Citarea de mai sus a fost facută aici doar pentru exemplificare.

% Asa se specifica folosirea unui fisier cu referinte bibliografice:
\bibliographystyle{ieeetr}
\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Bibliografie}  
\bibliography{bibliografie}

%% O alta varianta ar fi fost includerea de articole direct in acest fisier
%% in felul urmator:
%% \begin{thebibliography}{ABC}
%%
%% \bibitem{article}
%%  H. Baali, H. Djelouat, A. Amira and F. Bensaali,
%%  ``Empowering Technology Enabled Care Using IoT and Smart Devices:
%   A Review''. In: IEEE Sensors Journal, vol. 322 (10), pp. 891--921, 1905.
%%
%% (more \bibitem items here...)
%%
%% \end{thebibliography}

%% Daca vreti ca o sectiune sa inceapa pe o pagina noua, puteti forta acest lucru cu comanda "\newpage", ca mai jos:

%\newpage

%\chapter*{Anexe}\addcontentsline{toc}{chapter}{Anexe}
%Anexele sunt opționale.
%Ce poate intra în anexe:
%\begin{itemize}
%\item	Exemplu de fișier de configurare sau compilare;
%\item	Un tabel mai mare de o jumătate pagină;
%\item	O figura mai mare mai mare de jumătate pagină;
%\item	O secvență de cod sursa mai mare de jumătate pagină;
%\item	Un set de capturi de ecran (``screenshot''-uri);
%\item	Un exemplu de rulare a unor comenzi plus rezultatul (``output''-ul) acestora;
%\item 	În anexe intră lucruri care ocupă mai mult de o pagină ce ar întrerupe firul natural de parcurgere al textului.
%\end{itemize}
\begin{appendices}

\chapter{Extrase de cod} % Introduce o nouă anexă
\begin{lstlisting}[style={myC++}, caption = {Cazul triunghi în algoritmul GJK}, label={code:gjk_simplex3}]
void GJKEPA::GJKEPACollisionPointGenerator::doSimplex3() {
	/* simplex is a triangle ABC, A was just added */
	glm::vec3 vecAO = -simplex.a.v;
	glm::vec3 vecAB = simplex.b.v - simplex.a.v;
	glm::vec3 vecAC = simplex.c.v - simplex.a.v;
	glm::vec3 vecABC = glm::cross(vecAB, vecAC);
	
	if (glm::dot(glm::cross(vecABC, vecAC), vecAO) > 0) {
		if (glm::dot(vecAC, vecAO) > 0) {
			simplex.set(simplex.a, simplex.c);
			searchDir = glm::cross(glm::cross(vecAC, vecAO), vecAC);
		} else {
			if (glm::dot(vecAB, vecAO) > 0) {
				simplex.set(simplex.a, simplex.b);
				searchDir = glm::cross(glm::cross(vecAB, vecAO), vecAB);
			} else {
				simplex.set(simplex.a);
				searchDir = vecAO;
			}
		}
	} else {
		if (glm::dot(glm::cross(vecAB, vecABC), vecAO) > 0) {
			if (glm::dot(vecAB, vecAO) > 0) {
				simplex.set(simplex.a, simplex.b);
				searchDir = glm::cross(glm::cross(vecAB, vecAO), vecAB);
			} else {
				simplex.set(simplex.a);
				searchDir = vecAO;
			}
		} else {
			if (glm::dot(vecABC, vecAO) > 0) {
				searchDir = vecABC;
			} else {
				simplex.set(simplex.a, simplex.c, simplex.b);
				searchDir = -vecABC;
			}
		}
	}
}
\end{lstlisting}

\begin{lstlisting}[language=json, label={code:json_full}, caption={toate setarile disponibile pentru o scena in format .json}, float, floatplacement=t]
{
	"settings" : {
		"damping" : {
			"linear" : 0.9,
			"angular" : 0.9
		},
		"forceMultipliers" : {
			"torque" : 1.0,
			"force" : 1.0,
			"impulse" : 1.0
		},
		"gjkepa" : {
			"gjkMaxIters" : 100,
			"epaMaxIters" : 50
		},
		"collisionResolution" : {
			"penMaxIterations" : 5,
			"velMaxIterations" : 5,
			"minVelocityForRestitution" : 0.25,
			"angularMovementLimitFactor" : 0.2,
			"persistentContactDistanceThreshold" : 0.001,
			"coefInterpAlpha" : 0.5
		},
		"rigidBodies" : {
			"defaultMass" : 32.0,
			"defaultRestitutionCoef" : 0.1,
			"defaultFrictionCoef" : 0.6,
			"sleepMotionThreshold" : 0.1
		},
		"gravity" : {
			"x" : 0.0,
			"y" : -20.0,
			"z" : 0.0
		},
		"timeScale" : 1.0,
		"rendering" : {
			"renderColliders" : true,
			"renderContacts" : true,
			"renderContactNormals" : true,
			"renderSpawner" : true,
			"renderSelection" : true
		}
	},
	"objects" : [
		{
			"type" : "wall",
			"name" : "floor",
			"position" : {
				"x" : 0.0,
				"y" : -0.5,
				"z" : 0.0
			},
			"scale" : {
				"x" : 2.0,
				"y" : 2.0,
				"z" : 1.0
			},
			"orientation" : {
				"pitch" : 90.0,
				"yaw" : 0.0,
				"roll" : 0.0
			},
			"frictionCoef" : 0.6,
			"restitutionCoef" : 0.1,
			"mass" : -1.0
		}
	]
}
\end{lstlisting}

\chapter{Diagrame de clase}
\begin{figure}[H]
	\centering
	\makebox[\textwidth][c]{\includegraphics[width=0.9\linewidth]{pics/RigidBody.eps}}
	\caption[asdfas]{Definiția unui RigidBody}
	\label{fig:RigidBody}
\end{figure}

\begin{figure}[H]
	\centering
	\makebox[\textwidth][c]{\includegraphics[width=0.9\linewidth]{pics/CollisionDetection.eps}}
	\caption[]{Subsistemul de detecție de coliziuni}
	\label{fig:CollisionDetection}
\end{figure}

\begin{figure}[H]
	\centering
	\makebox[\textwidth][c]{\includegraphics[width=1.2\linewidth]{pics/CollisionResolution.eps}}
	\caption[]{Subsistemul de rezolvare a coliziunilor}
	\label{fig:CollisionResolution}
\end{figure}

\chapter{Capturi de ecran}
\begin{figure}[H]
	\centering
	\makebox[\textwidth][c]{\includegraphics[width=1.2\linewidth]{pics/screenshot1.png}}
	\caption[]{Controlul obiectului selectat}
	\label{fig:gui_object_control}
\end{figure}

\begin{figure}[H]
	\centering
	\makebox[\textwidth][c]{\includegraphics[width=1.2\linewidth]{pics/screenshot2.png}}
	\caption[]{Încărcarea de scene la runtime}
	\label{fig:gui_load_scene}
\end{figure}

\begin{figure}[H]
	\centering
	\makebox[\textwidth][c]{\includegraphics[width=1.2\linewidth]{pics/screenshot3.png}}
	\caption[]{Controlul elementelor desenate}
	\label{fig:gui_rendering}
\end{figure}

\begin{figure}[H]
	\centering
	\makebox[\textwidth][c]{\includegraphics[width=1.2\linewidth]{pics/screenshot4.png}}
	\caption[]{Controlul parametrilor de simulare}
	\label{fig:gui_simulation_settings}
\end{figure}
\end{appendices}
\end{document}
